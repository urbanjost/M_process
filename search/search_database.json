var tipuesearch = {"pages":[{"title":" M_process ","text":"M_process M_process Name M_process - read and write lines to or from a process from Fortran via a C wrapper Description The M_process Fortran module ( A fortran-lang.org package )\nreads and writes from processes by calling the C popen(3c) procedure. NB. These procedures require a platform that supports POSIX routines\nand the popen(3c) procedure in particular . Download and Build using make(1) Just download the github repository, enter the src/ directory and run make: git clone https://github.com/urbanjost/M_process.git cd M_process/src # change Makefile if not using one of the listed compilers # for gfortran make clean make F90 = gfortran gfortran # for ifort make clean make F90 = ifort ifort # for nvfortran make clean make F90 = nvfortran nvfortran # optionally make test # run the unit tests (needs M_framework(3f) module) make run --example \"*\" # run all the demo programs from the man-pages make help # see other developer options This will compile the M_process module and optionally build all the\nexample programs from the document pages in the example/ sub-directory\nand run the unit tests. Supports FPM (registered at the fpm(1) registry ) Alternatively, download the github repository and\nbuild it with fpm ( as described at Fortran Package\nManager ) git clone https://github.com/urbanjost/M_process.git cd M_process fpm build fpm test or just list it as a dependency in your fpm.toml project file. [dependencies] M_process = { git = \"https://github.com/urbanjost/M_process.git\" } Demo Programs The man-pages contain small sample programs that have been extracted\nand placed in the example/ directory. Documentation User There are currently several different ways to view the documentation … BOOK_M_process . manpage index and there are man-pages in the distribution in\n+ manpages.tgz or\n+ manpages.zip + CHANGELOG provides a history of significant changes Developer ford(1) output . doxygen(1) output . github action status Alternatives The Fortran Wiki fortranwiki.org contains\ninformation on other libraries and modules that provide access to processes and threads. Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"streampointer – M_process ","text":"type, public :: streampointer Components Type Visibility Attributes Name Initial type(c_ptr), public :: handle = c_null_ptr Source Code type , public :: streampointer type ( c_ptr ) :: handle = c_null_ptr end type streampointer","tags":"","url":"type/streampointer.html"},{"title":"test_suite_M_process – M_process","text":"subroutine test_suite_M_process() Uses M_framework__verify M_process setup\nteardown Arguments None Subroutines subroutine test_process_close () call process_close(fp,ierr)             ! not open yet\ncall unit_check(‘process_close’, ierr.ne.0, ‘close process before opening it’,ierr)\ncall unit_check(‘process_close’, ierr.eq.0, ‘close process that is open’,ierr) Arguments None subroutine test_process_open_read () call unit_check(‘process_open_read’, ierr.eq.0, ‘close ierr=’,ierr) Arguments None subroutine test_process_open_write () Arguments None subroutine test_process_readall () Arguments None subroutine test_process_readline () Arguments None subroutine test_process_writeline_array () Arguments None subroutine test_process_writeline_scalar () Arguments None Source Code subroutine test_suite_M_process () use M_framework__verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_process !! setup call test_process_open_read () call test_process_open_write () call test_process_readall () call test_process_readline () call test_process_writeline_array () call test_process_writeline_scalar () call test_process_close () !! teardown contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_close () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines character ( len = :), allocatable :: string ! hold results, assuming sufficient memory is available character ( len = 4096 ) :: line ! long enough to hold any expected line call unit_check_start ( 'process_close' , msg = '' ) string = '' !!call process_close(fp,ierr)             ! not open yet !!call unit_check('process_close', ierr.ne.0, 'close process before opening it',ierr) call process_open_read ( 'echo A;echo B;echo C' , fp , ierr ) ! open process to read from do ! read output of process till end call process_readline ( line , fp , ierr ) if ( ierr . ne . 0 ) exit string = string // trim ( line ) // ' ' ! append output lines together enddo call unit_check_msg ( 'process_close' , 'string=' , string ) call process_close ( fp , ierr ) ! Wrap up call unit_check ( 'process_close' , ierr . eq . 0 , 'close process ' , ierr ) call process_open_write ( 'cat' , fp , ierr ) ! open process to write to that is not terminated call process_close ( fp , ierr ) !!call unit_check('process_close', ierr.eq.0, 'close process that is open',ierr) call unit_check_done ( 'process_close' , msg = '' ) end subroutine test_process_close !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_open_read () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines character ( len = :), allocatable :: string ! hold results, assuming sufficient memory is available character ( len = 4096 ) :: line ! long enough to hold any expected line call unit_check_start ( 'process_open_read' , msg = '' ) string = '' call process_open_read ( 'echo a;echo b;echo c' , fp , ierr ) ! open process to read from call unit_check ( 'process_open_read' , ierr . eq . 0 , 'open ierr=' , ierr ) do ! read output of process till end call process_readline ( line , fp , ierr ) if ( ierr . ne . 0 ) exit string = string // trim ( line ) // '+' ! append output lines together enddo call unit_check ( 'process_open_read' , string . eq . 'a+b+c+' , string ) call process_open_read ( 'echo a;echo b;echo c' , fp , ierr ) ! open process to read from call unit_check ( 'process_open_read' , string . eq . 'a+b+c+' , 'open already open process,ierr=' , ierr ) call process_close ( fp , ierr ) ! Wrap up !!call unit_check('process_open_read', ierr.eq.0, 'close ierr=',ierr) call unit_check_done ( 'process_open_read' , msg = '' ) end subroutine test_process_open_read !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_open_write () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines integer :: lun integer :: ios character ( len = 256 ) :: line call unit_check_start ( 'process_open_write' , msg = '' ) ! clear scratch file open ( newunit = lun , file = '_scratch_.txt' , iostat = ios ) close ( unit = lun , iostat = ios , status = 'delete' ) ! start shell with command that finishes immediately (special case, would just use execute_command_line(3f) intrinsic) call process_open_write ( 'echo one >_scratch_.txt;echo two >>_scratch_.txt' , fp , ierr ) ! open process to write to call unit_check ( 'process_open_write' , ierr . eq . 0 , 'ierr=' , ierr ) call process_close ( fp , ierr ) call unit_check ( 'process_open_write' , ierr . eq . 0 , 'no error on close, ierr=' , ierr ) ! check expected file open ( newunit = lun , file = '_scratch_.txt' ) read ( lun , '(a)' , iostat = ios ) line call unit_check ( 'process_open_write' , line . eq . 'one' , 'line 1:' , line ) read ( lun , '(a)' , iostat = ios ) line call unit_check ( 'process_open_write' , line . eq . 'two' , 'line 2:' , line ) close ( unit = lun , iostat = ios , status = 'delete' ) ! start shell that waits to read commands call process_open_write ( 'bash||cmd' , fp , ierr ) ! open process to write to call unit_check ( 'process_open_write' , ierr . eq . 0 , 'ierr=' , ierr ) call process_writeline ( 'echo three >_scratch_.txt' , fp , ierr ) call unit_check ( 'process_open_write' , ierr . ge . 0 , 'write of \"echo three >_scratch_.txt\", ierr=' , ierr ) call process_writeline ( 'echo four >>_scratch_.txt' , fp , ierr ) call unit_check ( 'process_open_write' , ierr . ge . 0 , 'write of \"echo four >>_scratch_.txt\", ierr=' , ierr ) call process_close ( fp , ierr ) call unit_check ( 'process_open_write' , ierr . eq . 0 , 'should now be closed, ierr=' , ierr ) ! check expected file open ( newunit = lun , file = '_scratch_.txt' ) read ( lun , '(a)' , iostat = ios ) line call unit_check ( 'process_open_write' , line . eq . 'three' , 'line 1:' , line ) read ( lun , '(a)' , iostat = ios ) line call unit_check ( 'process_open_write' , line . eq . 'four' , 'line 2:' , line ) close ( unit = lun , iostat = ios , status = 'delete' ) ! call unit_check_done ( 'process_open_write' , msg = '' ) end subroutine test_process_open_write !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_readall () integer :: ierr character ( len = :), allocatable :: string string = process_readall ( 'echo A;echo B;echo C' , ierr = ierr ) call unit_check_start ( 'process_readall' , msg = '' ) call unit_check ( 'process_readall' , string . eq . 'A B C' , string ) call unit_check_done ( 'process_readall' , msg = '' ) end subroutine test_process_readall !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_readline () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines character ( len = :), allocatable :: string ! hold results, assuming sufficient memory is available character ( len = 4096 ) :: line ! long enough to hold any expected line call unit_check_start ( 'process_readline' , msg = '' ) string = '' call process_open_read ( 'echo a;echo b;echo c' , fp , ierr ) ! open process to read from do ! read output of process till end call process_readline ( line , fp , ierr ) if ( ierr . ne . 0 ) exit string = string // trim ( line ) // '+' ! append output lines together enddo call unit_check ( 'process_readline' , string . eq . 'a+b+c+' , string ) call process_close ( fp , ierr ) ! Wrap up call unit_check_done ( 'process_readline' , msg = '' ) end subroutine test_process_readline !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_writeline_array () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines integer :: lun integer :: ios integer :: i character ( len = :), allocatable :: text (:) character ( len =* ), parameter :: lines ( * ) = [ character ( len = 10 ) :: 'one' , 'two' , 'three' , 'four' ] character ( len = 256 ) :: line call unit_check_start ( 'process_writeline_array' , msg = '' ) ! clear scratch file open ( newunit = lun , file = '_scratch_.txt' , iostat = ios ) close ( unit = lun , iostat = ios , status = 'delete' ) ! start shell call process_open_write ( 'bash||cmd' , fp , ierr ) ! open process to write to ! feed commands to shell that redirect output to _scratch_.txt file text = [ character ( len = 128 ) :: & \"echo one   >_scratch_.txt\" , & \"echo two   >>_scratch_.txt\" , & \"echo three >>_scratch_.txt\" , & \"echo four  >>_scratch_.txt\" ] call process_writeline ( text , fp , ierr ) ! multiple lines call unit_check ( 'process_writeline_array' , ierr . ge . 0 , 'wrote four lines, ierr=' , ierr ) call process_close ( fp , ierr ) ! check expected file open ( newunit = lun , file = '_scratch_.txt' ) do i = 1 , 4 read ( lun , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit call unit_check ( 'process_writeline_array' , line . eq . lines ( i ), 'got ' , line , 'expected' , line ) enddo close ( unit = lun , iostat = ios , status = 'delete' ) call unit_check ( 'process_writeline_array' , i . eq . 5 , 'number of lines' , i - 1 ) call unit_check_done ( 'process_writeline_array' , msg = '' ) end subroutine test_process_writeline_array !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_writeline_scalar () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines integer :: lun integer :: ios integer :: i character ( len =* ), parameter :: lines ( * ) = [ character ( len = 10 ) :: 'one' , 'two' , 'three' , 'four' ] character ( len = 256 ) :: line call unit_check_start ( 'process_writeline_scalar' , msg = '' ) ! clear scratch file open ( newunit = lun , file = '_scratch_.txt' , iostat = ios ) close ( unit = lun , iostat = ios , status = 'delete' ) ! start shell call process_open_write ( 'bash||cmd' , fp , ierr ) ! open process to write to (ie. start gnuplot(1) program) ! feed commands to shell that redirect output to _scratch_.txt file call process_writeline ( 'echo one    >_scratch_.txt' , fp , ierr ) call process_writeline ( 'echo two   >>_scratch_.txt' , fp , ierr ) call process_writeline ( 'echo three >>_scratch_.txt' , fp , ierr ) call process_writeline ( 'echo four  >>_scratch_.txt' , fp , ierr ) call process_close ( fp , ierr ) ! check expected file open ( newunit = lun , file = '_scratch_.txt' ) do i = 1 , size ( lines ) read ( lun , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit call unit_check ( 'process_writeline_scalar' , line . eq . lines ( i ), line ) enddo close ( unit = lun , iostat = ios , status = 'delete' ) call unit_check ( 'process_writeline_scalar' , i . eq . 5 , 'number of lines' , i ) call unit_check_done ( 'process_writeline_scalar' , msg = '' ) end subroutine test_process_writeline_scalar !=================================================================================================================================== end subroutine test_suite_M_process","tags":"","url":"proc/test_suite_m_process.html"},{"title":"process_readall – M_process","text":"public  function process_readall(cmd, delim, ierr) result(string) NAME proc ess_readall ( 3 f ) - [ M_process ] read all lines from process into single string ( LICENSE: PD ) SYNOPSIS syntax: function process_readall(cmd,delim,ierr)  result ( string ) character ( len = * ), intent ( in ) :: cmd character ( len = * ), intent ( in ), optional :: delim integer , intent ( out ), optional :: ierr character ( len =:), allocatable :: string OPTIONS cmd        command to pass to system\n   delim      delimiter to place between output lines when they\n              are concatenated. Defaults to a space\n   ierr       check status of call. RESULTS process_readall   Assuming sufficient memory is available all the\n                     output of the system command are concatenated\n                     into a string with spaces added between the\n                     output lines of the command. EXAMPLE Read all output of a command to a single string program demo_process_readall use M_process , only : process_readall implicit none integer :: ierr character ( len =:), allocatable :: string string = process_readall ( ' ls ' , ierr = ierr ) write ( * , * ) ierr , string end program demo_process_readall Results: app build docs example fpm.toml LICENSE man README.md src test Read all output of a command to an array using split(3f) program test_process_readall use M_process , only : process_readall use M_strings , only : split implicit none integer :: ierr integer :: i character ( len =:), allocatable :: string character ( len =:), allocatable :: array (:) string = process_readall ( ' ls ' , delim = NEW_LINE ( \"A\" ), ierr = ierr ) call split ( string , array , delimiters = NEW_LINE ( \"A\" )) do i = 1 , size ( array ) write ( * , ' ( i0 , t10 , \"[\" , a , \"]\" ) ' ) i , trim ( array ( i )) enddo write ( * , * ) string = process_readall ( & & ' ls ' , delim = NEW_LINE ( \"A\" ), ierr = ierr ) write ( * , * ) string end program test_process_readall Results: > 1 [ Articles ] > 2 [ LIBRARY ] > 3 [ PC ] > 4 [ SHIP ] > 5 [ SPEC ] > 6 [ crib.dat ] > 7 [ doc ] > 8 [ html ] > 9 [ index.html ] > 10 [ plan.txt ] > 11 [ questions ] > 12 [ scripts ] > 13 [ tmp ] SEE ALSO M_process(3fm) AUTHOR John S. Urban LICENSE Public Domain not hardened change to stream I/O so do not have to have arbitrary line length limit,\n or at least make length an option\nwrite( , )’ M_process::process_readall(3f) error values=’,ierr_local Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd character(len=*), intent(in), optional :: delim integer, intent(out), optional :: ierr Return Value character(len=:), allocatable assume will not run out of memory Source Code function process_readall ( cmd , delim , ierr ) result ( string ) !! not hardened ! ident_7=\"@(#) M_process process_readall(3f) read all lines from process\" character ( len =* ), intent ( in ) :: cmd character ( len = :), allocatable :: string !! assume will not run out of memory character ( len =* ), intent ( in ), optional :: delim integer , intent ( out ), optional :: ierr character ( len = :), allocatable :: delim_local integer :: ierr_local ( 3 ), ierr_read integer :: i type ( streampointer ) :: fp character ( len = 4096 ) :: line !! assumed long enough !------------------------------------------------------------------------------- if ( present ( delim )) then delim_local = delim else delim_local = ' ' endif !! change to stream I/O so do not have to have arbitrary line length limit, !! or at least make length an option string = '' ierr_local (:) = 0 call process_open_read ( cmd , fp , ierr_local ( 1 )) ! start command if ( ierr_local ( 1 ). eq . 0 ) then do ! read line from command output call process_readline ( line , fp , ierr_read ) if ( ierr_read . ne . 0 ) then exit endif string = string // trim ( line ) // delim_local enddo string = trim ( string ) endif call process_close ( fp , ierr_local ( 3 )) ! Wrap up if ( present ( ierr )) then do i = 1 , size ( ierr_local ) if ( ierr_local ( i ). ne . 0 ) then ierr = ierr_local ( i ) exit endif enddo elseif ( any ( ierr_local . ne . 0 )) then !!write(*,*)'*M_process::process_readall(3f)* error values=',ierr_local stop \"*M_process::process_readall(3f)* error\" endif end function process_readall","tags":"","url":"proc/process_readall.html"},{"title":"process_close – M_process","text":"public  subroutine process_close(fp, ierr) NAME proc ess_close ( 3 fm ) - [ M_process ] close a process being written to or read from ( LICENSE: PD ) SYNOPSIS subroutine process_close ( fp , ierr ) type ( streampointer ) :: fp integer :: ierr DESCRIPTION The M_process Fortran procedures use the ISO_C_BINDING\n   interface to define Fortran-callable versions of the C procedures\n   popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented\n   wrapper routines are then used to create a simple Fortran-callable\n   interface. A POSIX C interface is generally available but may require using a\n   Linux subwindow or an application such as CygWin on MSWindows platforms. See “M_process” for an extended description. OPTIONS fp       C file pointer returned by process_open_*()\nierr     error flag returned. EXAMPLES This example shows a simple open and close of a process program demo_process_close\n   use M_process ,ONLY: process_open_read, process_open_write\n   use M_process ,ONLY: streampointer, process_close\n   implicit none\n   type(streampointer) :: fp\n   integer             :: ierr\n     ! open process to read from\n     call process_open_read(‘ls -l’,fp,ierr)\n     write( , )’CLOSE   : process is opened with status ‘,ierr\n     call process_close(fp,ierr)\n     write( , )’CLOSE   : process closed with status ‘,ierr\n   end program demo_process_close Sample output: CLOSE   : process is opened with status            0\n CLOSE   : process closed with status           13 SEE ALSO o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c)\no NAMED PIPES: mkfifo(3c), mknod(3c)\no SUBPROCESSES: fork(3c)\no OTHER: fflush(3c) AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name type( streampointer ) :: fp integer, intent(out) :: ierr Source Code subroutine process_close ( fp , ierr ) ! ident_5=\"@(#) M_process process_close(3f) close process\" ! file pointer returned for process ! DO NOT MAKE fp INTENT(IN) type ( streampointer ) :: fp integer ( c_int ) :: ios integer , intent ( out ) :: ierr !------------------------------------------------------------------------------- ios = 0_c_int if (. not . c_associated ( fp % handle )) then write ( * , * ) '*process_close* process not found' else ios = fflush ( fp % handle ) if ( ierr . ge . 0 ) then ios = system_pclose ( fp % handle ) endif endif if ( process_debug ) then write ( * , * ) '*process_close* Closed pipe with status ' , ios endif ierr = ios end subroutine process_close","tags":"","url":"proc/process_close.html"},{"title":"process_open_read – M_process","text":"public  subroutine process_open_read(cmd, fp, ierr) NAME proc ess_open_read ( 3 fm ) - [ M_process ] open a process for reading using POSIX interface ( LICENSE: PD ) SYNOPSIS subroutine process_open_read ( cmd , fp , ierr ) character ( len = * ) :: cmd type ( streampointer ) :: fp integer :: ierr DESCRIPTION The M_process Fortran procedures use the ISO_C_BINDING interface to define\n   Fortran-callable versions of the C procedures popen(3c)/pclose(3c)\n   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines\n   are then used to create a simple Fortran-callable interface. A POSIX C interface is generally available but may require using a Linux\n   subwindow or an application such as CygWin on MSWindows platforms. See “M_process” for an extended description. OPTIONS cmd      command passed to system to start process\nfp       C file pointer returned by process_open_*()\nierr     error flag returned.\n\n          o process_writeline(3f) : negative indicates an error\n          o process_readline(3f)  : Non-zero indicates an error\n\nmaximum character value length is currently 4096 EXAMPLES This example shows a routine to read the output of a system command. program demo_process_open_read\n   use M_process ,ONLY: process_open_read, process_readline\n   use M_process ,ONLY: streampointer, process_close\n   implicit none\n   type(streampointer) :: fp\n   ! line of data to read (assumed long enough to hold any output line)\n   character(len=4096) :: line\n   integer             :: ierr\n     ! open process to read from\n     call process_open_read(‘ls -l’,fp,ierr)\n     write( , )’READTEST: process is opened with status ‘,ierr\n     ierr=0\n     do while(ierr .eq. 0)\n       ! read a line from the process\n       call process_readline(line,fp,ierr)\n       if(ierr.ne.0)then\n         write( , )’READTEST: ierr is ‘,ierr\n         exit\n       endif\n       write( , )’READTEST: ‘,trim(line)\n     enddo\n     call process_close(fp,ierr)\n     write( , )’READTEST: process closed with status ‘,ierr\n   end program demo_process_open_read Sample output: READTEST: process is opened with status            0\n   READTEST: total 108\n   READTEST: -rw-r–r–. 1 urbanjs urbanjs  3731 Oct 17 14:49 build.sh\n   READTEST: -rw-rw-r–. 1 urbanjs urbanjs 56633 Oct 17 14:50 build.sh.log\n   READTEST: drwxrwxr-x. 3 urbanjs urbanjs  4096 Oct 17 14:50 doc\n   READTEST: -rw-rw-r–. 1 urbanjs urbanjs 39459 Oct 17 15:16 M_process.ff\n   READTEST: -rw-rw-r–. 1 urbanjs urbanjs   826 Oct 17 15:17 xx.f90\n   READTEST: ierr is           -1\n   READTEST: process closed with status            0 SEE ALSO o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c)\no NAMED PIPES: mkfifo(3c), mknod(3c)\no SUBPROCESSES: fork(3c)\no OTHER: fflush(3c) AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd type( streampointer ), intent(out) :: fp integer, intent(out) :: ierr Source Code subroutine process_open_read ( cmd , fp , ierr ) ! ident_2=\"@(#) M_process process_open_read(3f) open process to read from\" ! shell command to start process with character ( len =* ), intent ( in ) :: cmd ! file pointer returned for process type ( streampointer ), intent ( out ) :: fp ! status for attempt to open process (0= no error) integer , intent ( out ) :: ierr ! read/write mode parameter to pass to popen(3c) character ( len = 3 ), parameter :: mode = 'r' !------------------------------------------------------------------------------- ierr = 0 call process_open ( cmd , mode , fp , ierr ) end subroutine process_open_read","tags":"","url":"proc/process_open_read.html"},{"title":"process_open_write – M_process","text":"public  subroutine process_open_write(cmd, fp, ierr) NAME proc ess_open_write ( 3 fm ) - [ M_process ] open a process for writing using a POSIX interface ( LICENSE: PD ) SYNOPSIS subroutine process_open_write ( cmd , fp , ierr ) character ( len = * ) :: cmd type ( streampointer ) :: fp integer :: ierr DESCRIPTION The M_process Fortran procedures use the ISO_C_BINDING interface to define\n   Fortran-callable versions of the C procedures popen(3c)/pclose(3c)\n   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines\n   are then used to create a simple Fortran-callable interface. A POSIX C interface is generally available but may require using a Linux\n   subwindow or an application such as CygWin on MSWindows platforms. See “M_process” for an extended description. OPTIONS cmd      command passed to system to start process\nfp       C file pointer returned by process_open_*()\nierr     error flag returned.\n\n          o process_writeline(3f) : negative indicates an error\n          o process_readline(3f)  : Non-zero indicates an error\n\nmaximum character value length is currently 4096 EXAMPLES This example shows a routine to write lines to the stdin of a system process program demo_process_open_write\n   use, intrinsic :: iso_fortran_env, only : &\n   & stdin=>input_unit, &\n   & stdout=>output_unit, &\n   & stderr=>error_unit\n   use M_process ,ONLY: process_open_write, process_writeline\n   use M_process ,ONLY: streampointer, process_close\n   implicit none\n   type(streampointer) :: fp\n   ! line of data to write\n   character(len=4096) :: line\n   integer             :: ierr\n   integer             :: i\n     ! open process to write to\n     call process_open_write(‘cat -n’,fp,ierr)\n     write(stdout, )’OPENWTEST: process is opened with status ‘,ierr\n     ! remember C and Fortran I/O are often independent of each other\n     flush(stdout)\n     ierr=0\n     line=’xxxxxxxxxxxxxxxxxxxxxxxxxxx’\n     do i=1,10\n       ! write a line to the process\n       call process_writeline(trim(line),fp,ierr)\n       if(ierr.lt.0)then\n         write(stdout, )’OPENWTEST: ierr is ‘,ierr\n         exit\n       endif\n     enddo\n     call process_close(fp,ierr)\n     write(stdout,*)’OPENWTEST: process closed with status ‘,ierr\n   end program demo_process_open_write Sample output: OPENWTEST: process is opened with status            0\n   1        xxxxxxxxxxxxxxxxxxxxxxxxxxx\n   2        xxxxxxxxxxxxxxxxxxxxxxxxxxx\n   3        xxxxxxxxxxxxxxxxxxxxxxxxxxx\n   4        xxxxxxxxxxxxxxxxxxxxxxxxxxx\n   5        xxxxxxxxxxxxxxxxxxxxxxxxxxx\n   6        xxxxxxxxxxxxxxxxxxxxxxxxxxx\n   7        xxxxxxxxxxxxxxxxxxxxxxxxxxx\n   8        xxxxxxxxxxxxxxxxxxxxxxxxxxx\n   9        xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  10        xxxxxxxxxxxxxxxxxxxxxxxxxxx\nOPENWTEST: process closed with status            0 SEE ALSO o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c)\no NAMED PIPES: mkfifo(3c), mknod(3c)\no SUBPROCESSES: fork(3c)\no OTHER: fflush(3c) AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd type( streampointer ), intent(out) :: fp integer, intent(out) :: ierr Source Code subroutine process_open_write ( cmd , fp , ierr ) ! ident_3=\"@(#) M_process process_open_write(3f) open process to write to\" ! shell command to start process with character ( len =* ), intent ( in ) :: cmd ! file pointer returned for process type ( streampointer ), intent ( out ) :: fp ! status for attempt to open process (0= no error) integer , intent ( out ) :: ierr ! read/write mode parameter to pass to popen(3c) character ( len = 3 ), parameter :: mode = 'w' !------------------------------------------------------------------------------- ierr = 0 call process_open ( cmd , mode , fp , ierr ) end subroutine process_open_write","tags":"","url":"proc/process_open_write.html"},{"title":"process_readline – M_process","text":"public  subroutine process_readline(readfrom, fp, ierr) NAME proc ess_readline ( 3 fm ) - [ M_process ] read a line of output from a system command as a character variable ( LICENSE: PD ) SYNOPSIS subroutine process_readline ( string , fp , ierr ) character ( len = * ) :: string type ( streampointer ) :: fp integer :: ierr DESCRIPTION The M_process Fortran procedures use the ISO_C_BINDING\n   interface to define Fortran-callable versions of the C procedures\n   popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented\n   wrapper routines are then used to create a simple Fortran-callable\n   interface. A POSIX C interface is generally available but may require using a\n   Linux subwindow or an application such as CygWin on MSWindows platforms. See “M_process” for an extended description. OPTIONS string   data line to receive from process\nfp       C file pointer returned by process_open_*()\nierr     error flag returned.\n\n          o process_writeline(3f) : negative indicates an error\n          o process_readline(3f)  : Non-zero indicates an error\n\nmaximum character value length is currently 4096 EXAMPLES This example shows a routine reading the output of a system command. program demo_process_readline\n   use M_process ,ONLY: process_open_read, process_readline\n   use M_process ,ONLY: streampointer, process_close\n   implicit none\n   type(streampointer) :: fp\n   ! line of data to read (assumed long enough to hold any output line)\n   character(len=4096) :: line\n   integer             :: ierr\n     ! open process to read from\n     call process_open_read(‘ls -l’,fp,ierr)\n     write( , )’READLINE: process is opened with status ‘,ierr\n     ierr=0\n     do while(ierr .eq. 0)\n       ! read a line from the process\n       call process_readline(line,fp,ierr)\n       if(ierr.ne.0)then\n         write( , )’READLINE: ierr is ‘,ierr\n         exit\n       endif\n       write( , )’READLINE: ‘,trim(line)\n     enddo\n     call process_close(fp,ierr)\n     write( , )’READLINE: process closed with status ‘,ierr\n   end program demo_process_readline Sample output: READLINE: process is opened with status            0\n   READLINE: total 108\n   READLINE: -rw-r–r–. 1 urbanjs urbanjs  3731 Oct 17 14:49 build.sh\n   READLINE: -rw-rw-r–. 1 urbanjs urbanjs 56633 Oct 17 14:50 build.sh.log\n   READLINE: drwxrwxr-x. 3 urbanjs urbanjs  4096 Oct 17 14:50 doc\n   READLINE: -rw-rw-r–. 1 urbanjs urbanjs 39459 Oct 17 15:16 M_process.ff\n   READLINE: -rw-rw-r–. 1 urbanjs urbanjs   826 Oct 17 15:17 xx.f90\n   READLINE: ierr is           -1\n   READLINE: process closed with status            0 SEE ALSO o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c)\no NAMED PIPES: mkfifo(3c), mknod(3c)\no SUBPROCESSES: fork(3c)\no OTHER: fflush(3c) AUTHOR John S. Urban LICENSE Public Domain ios = system_pclose(fp%handle)\nif(process_debug)then\n   write( , ) ‘ process_readline Closed pipe with status ‘,ios\nendif Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: readfrom type( streampointer ), intent(in) :: fp integer, intent(out) :: ierr Source Code subroutine process_readline ( readfrom , fp , ierr ) ! ident_6=\"@(#) M_process process_readline(3f) read line from process\" ! readfrom length must be at least two character ( len =* ), intent ( out ) :: readfrom type ( streampointer ), intent ( in ) :: fp integer , intent ( out ) :: ierr integer ( kind = c_int ) :: clen integer :: eos , i integer :: ios clen = len ( readfrom ) - 1 readfrom = ' ' do while ( c_associated ( system_fgets ( readfrom , clen , fp % handle ))) eos = 2 do i = 1 , clen if ( readfrom ( i : i ) == C_NULL_CHAR ) then eos = i - 2 ! assuming line terminator character and ! line string terminator should not be printed readfrom ( eos + 1 :) = ' ' exit endif enddo if ( process_debug ) then write ( * , * ) eos , ': \"' , trim ( readfrom ( 1 : eos )), '\"' endif ierr = 0 return end do ! an error occurred ios = 0 !!ios = system_pclose(fp%handle) !!if(process_debug)then !!   write(*,*) '*process_readline* Closed pipe with status ',ios !!endif ierr = min ( - 1 , ios ) end subroutine process_readline","tags":"","url":"proc/process_readline.html"},{"title":"process_writeline – M_process","text":"public interface process_writeline Module Procedures private  subroutine process_writeline_scalar(writefrom, fp, ierr, trm) NAME proc ess_writeline ( 3 fm ) - [ M_process ] write to a process using a POSIX interface ( LICENSE: PD ) SYNOPSIS subroutine process_writeline ( string , fp , ierr ) character ( len = * ) :: string type ( streampointer ) :: fp integer :: ierr DESCRIPTION The M_process Fortran procedures use the ISO_C_BINDING interface to define\n   Fortran-callable versions of the C procedures popen(3c)/pclose(3c)\n   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines\n   are then used to create a simple Fortran-callable interface. A POSIX C interface is generally available but may require using a Linux\n   subwindow or an application such as CygWin on MSWindows platforms. See “M_process” for an extended description. OPTIONS string   data line to to process\nfp       C file pointer returned by process_open_*()\nierr     error flag returned.\n\n          o process_writeline(3f) : negative indicates an error\n          o process_readline(3f)  : Non-zero indicates an error\n\nmaximum character value length is currently 4096 EXAMPLES This example shows a routine to write lines to the stdin of a system process program demo_process_writeline\n   use, intrinsic :: iso_fortran_env, only : &\n      & stdin=>input_unit, &\n      & stdout=>output_unit, &\n      & stderr=>error_unit\n   use m_process ,only: process_open_write, process_writeline\n   use m_process ,only: streampointer, process_close\n   implicit none\n   type(streampointer) :: fp\n   ! line of data to write\n   character(len=4096) :: line\n   integer             :: ierr\n   integer             :: i\n     ! open process to write to\n     call process_open_write(‘cat -n’,fp,ierr)\n     write( , )’WRITETEST: process is opened with status ‘,ierr\n     ! remember C and Fortran I/O are often independent of each other\n     flush(stdout)\n     ierr=0\n     line=’xxxxxxxxxxxxxxxxxxxxxxxxxxx’\n     do i=1,10\n       ! write a line to the process\n       call process_writeline(trim(line),fp,ierr)\n       if(ierr.lt.0)then\n         write( , )’WRITETEST: ierr is ‘,ierr\n         exit\n       endif\n     enddo\n     call process_close(fp,ierr)\n     write( , )’WRITETEST: process closed with status ‘,ierr\n   end program demo_process_writeline Sample output: WRITETEST: process is opened with status            0\n  1 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  2 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  3 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  4 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  5 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  6 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  7 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  8 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  9 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n 10 xxxxxxxxxxxxxxxxxxxxxxxxxxx\nWRITETEST: process closed with status            0 SEE ALSO o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c)\no NAMED PIPES: mkfifo(3c), mknod(3c)\no SUBPROCESSES: fork(3c)\no OTHER: fflush(3c) AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: writefrom type( streampointer ), intent(in) :: fp integer, intent(out) :: ierr logical, intent(in), optional :: trm private  subroutine process_writeline_array(writefrom, fp, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: writefrom (:) type( streampointer ), intent(in) :: fp integer, intent(out) :: ierr","tags":"","url":"interface/process_writeline.html"},{"title":"plotit – M_process","text":"subroutine plotit(step) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: step Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: g = '(*(g0,1x))' integer, public :: i integer, public :: ierr character(len=80), public :: line character(len=10), public :: step_local Source Code subroutine plotit ( step ) character ( len =* ), intent ( in ), optional :: step character ( len = 10 ) :: step_local character ( len = 80 ) :: line character ( len =* ), parameter :: g = '(*(g0,1x))' integer :: ierr integer :: i if ( present ( step )) then select case ( step ) case ( 'start' ) call process_open_write ( 'gnuplot --persist' , fp , ierr ) write ( stdout , * ) 'WRITETEST: process is opened with status ' , ierr call process_writeline ( [ character ( len = 80 ) :: & 'set terminal X11' ,& 'set nokey' ,& 'set title \" example of gnuplot data and command file generation\"' ],& fp , ierr ) case ( 'stop' ) call process_close ( fp , ierr ) write ( * , * ) 'WRITETEST: process closed with status ' , ierr end select else call process_writeline ( '$set1 <<eod' , fp , ierr ) ierr = 0 do i = 1 , n write ( line , g ) ' ' , x ( i ) , y ( i ) !x! write the x,y array as coordinates to be plotted. call process_writeline ( trim ( line ), fp , ierr ) if ( ierr . lt . 0 ) then write ( * , * ) 'WRITETEST: ierr is ' , ierr exit endif enddo call process_writeline ( 'eod' , fp , ierr ) call process_writeline ( 'plot $set1 with lines lw 4' , fp , ierr ) endif end subroutine plotit","tags":"","url":"proc/plotit.html"},{"title":"test_suite_M_process – M_process","text":"interface subroutine test_suite_M_process() Arguments None","tags":"","url":"interface/test_suite_m_process.html"},{"title":"M_process – M_process","text":"NAME M_process(3fm) - [M_process::INTRO] Fortran Module for calling\n                 process-related C functions from Fortran\n(LICENSE:PD) SYNOPSIS use M_process, only : process_open_read, process_open_write, process_close\n\n use M_process, only : process_readline, process_readall, process_writeline\n\n use M_process, only : streampointer, process_debug DESCRIPTION Module M_process(3f) lets Fortran code read/write lines from/to processes. These Fortran procedures use the ISO_C_BINDING interface to define\n   Fortran-callable versions of the C procedures popen(3c)/pclose(3c)\n   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines\n   are then used to create a simple Fortran-callable interface. A POSIX C interface is generally available but may require using a Linux\n   subwindow or an application such as CygWin on MSWindows platforms. Basically, you o Open a process for either reading from or writing to using formatted\n     sequential text records (eg. “lines”); much like with a regular file.\n   o pass a CHARACTER variable to/from the process that represents\n     a record.\n   o Use internal READs and internal WRITEs or parsing routines to\n     create or interpret the lines.\n   o when done close the process much like closing a file. The procedures defined are: ! open process to read from subroutine process_open_read ( cmd , fp , ierr ) ! open process to write to subroutine process_open_write ( cmd , fp , ierr ) ! read line from process subroutine process_readline ( string , fp , ierr ) ! read all of process output into a string string function process_readall ( cmd , ierr ) result ( string ) ! write lines to process subroutine process_writeline & & ( string | string_array , fp , ierr [, trm =. t .|. f . ]) ! close process subroutine process_close ( fp , ierr ) where the variable types are character ( len =* ) :: cmd type ( streampointer ) :: fp character ( len =* ) :: string integer :: ierr OPTIONS cmd      command passed to system to start process\nfp       C file pointer returned by process_open_*()\nstring   data line to send or receive from process\nierr     error flag returned.\n\n          o process_writeline(3f) : negative indicates an error\n          o process_readline(3f)  : Non-zero indicates an error\n\nmaximum character value length is currently 4096 EXAMPLES An example that places all the output of a command into a single\n string variable (see process_readall(3) for an even simpler way to\n do this) … program read_ex use M_process , only : process_open_read , process_readline use M_process , only : streampointer , process_close implicit none ! C file pointer returned by process_open () type ( streampointer ) :: fp ! check status of calls to process module routines integer :: ierr ! hold results , assuming sufficient memory is available character ( len =:), allocatable :: string ! long enough to hold any expected line character ( len = 4096 ) :: line string = '' ! ### ! open process to read from call process_open_read ( ' ls ' , fp , ierr ) ! ### ! read output of process till end do call process_readline ( line , fp , ierr ) if ( ierr . ne .0 ) exit ! ### ! append output lines together string = string //trim(line)//' ' write ( * , * ) '[' //string//']' enddo write ( * , * ) trim ( string ) ! ### ! Wrap up call process_close ( fp , ierr ) end program read_ex When calling a line-mode program from another program the most natural\n way is to open a process and write to it. Following is an example program that calls the M_process module to\n start a plotting program called gnuplot(1) and give it enough commands\n to generate a plot. It then lets you interactively interact with the\n gnuplot(1) program or continue on in the program. program gnuplotExample\n   use M_process ,only: process_open_write, process_writeline\n   use M_process ,only: streampointer, process_close\n   implicit none\n   !\n   ! Example of Fortran writing GNUPLOT command and data file.\n   !\n   ! ! line of data to write\n   ! ! (assumed long enough to hold any command line)\n   character(len=4096) :: line\n   ! ! C file pointer returned by process_open()\n   type(streampointer) :: fp\n   ! ! check status of calls to process module routines\n   integer :: ierr\n   ! ! DO loop counter\n   integer :: i\n   ! ! number of points to put into curve to be plotted\n   integer,parameter   :: n=50\n   ! ! arrays to fill with curve data to be plotted\n   real                :: x(n),y(n)\n   integer             :: ios\n   ! ! Define sample X,Y array.\n   do i=1,n\n   ! ! set X() values as whole numbers 1 to N\n      x(i)=i\n      ! !\n      y(i)=(x(i)+0.5) 2\n   enddo\n   ! ! Write the GnuPlot commands\n   ! ! open process to write to (ie. start gnuplot(1) program)\n   call process_open_write(‘gnuplot’,fp,ierr)\n   ! ! create in-line dataset $SET1\n   call process_writeline(‘$SET1 <<EOD’,fp,ierr)\n   do i=1,n\n      ! ! Write the X,Y array as coordinates to be plotted.\n      write(line,’(2(f10.3,1x))’)x(i),y(i)\n      call process_writeline(line,fp,ierr)\n   enddo call process_writeline([character(len=128) ::                        &\n   &’EOD                                                             ‘, &\n   &’set title ” Example of GNUPlot data and command file generation”’, &\n   &’set nokey’                                                       , &\n   &’plot $SET1 with lines’                                           , &\n   &’‘],fp,ierr) ! ! Additional gnuplot commands; in this case interactively entered\n   write( ,’(a)’)’enter gnuplot commands or “.” to exit’\n   do\n      write( ,’(a)’,advance=’no’)’gnu>>’\n      read( ,’(a)’,iostat=ios)line\n      if(line.eq.’.’)exit\n      call process_writeline(trim(line),fp,ierr)\n   enddo\n   ! ! Wrap up\n   call process_close(fp,ierr)\n   write( ,*)’CLOSED THE PROCESS. RETURNING TO PROGRAM’\n   end program gnuplotExample This program starts a bash shell that, among other things, calls\n sqlite3 and gnuplot. In this case the text is fixed to keep the example\n simple. More typically the text would be conditionally selected or\n generated by the program. program demo_M_process use M_process , only : process_open_write , process_writeline use M_process , only : streampointer , process_close implicit none ! C file pointer returned by process_open () type ( streampointer ) :: fp ! check status of calls to process module routines integer :: ierr character ( len =:), allocatable :: text (:) ! open process to write to ( ie . start gnuplot ( 1 ) program ) !! call process_open_write ( ' cat ' , fp , ierr ) ! open process to write to ( ie . start gnuplot ( 1 ) program ) call process_open_write ( ' bash ' , fp , ierr ) text =[ character ( len = 128 ) :: & \"rm -f sqlite1.db\" , & \"sqlite3 sqlite1.db <<\\EOF\" , & \"-- ***********************************************\" , & \"CREATE TABLE IF NOT EXISTS animals(               \" , & \"   name        TEXT   NOT NULL   PRIMARY KEY ,    \" , & \"   hair        INT    NOT NULL   ,                \" , & \"   mobility    INT    NOT NULL   ,                \" , & \"   vision      INT    NOT NULL   );               \" , & \"-- ***********************************************\" , & \"INSERT INTO animals(& &name,hair,mobility,vision) VALUES('kittens',4,5,1);\" , & \"INSERT INTO animals(& &name,hair,mobility,vision) VALUES('mice'   ,6,7,2);\" , & \"INSERT INTO animals(& &name,hair,mobility,vision) VALUES('rats'   ,2,3,3);\" , & \"-- ***********************************************\" , & \".quit\" , & \"EOF\" , & \"##################################################\" , & \"sqlite3 -header -column sqlite1.db  'select * from animals'\" , & \"sqlite3 sqlite1.db  & &'select name, hair, mobility, vision from animals'\" , & \"##################################################\" , & \"gnuplot --persist <<\\EOF                          \" , & \"########################################          \" , & \"#set terminal gif                                 \" , & \"#set output 'M_process.3.gif'                     \" , & \"########################################          \" , & \"#set terminal png                                 \" , & \"#set output 'bar.png'                             \" , & \"########################################          \" , & \"#set terminal pdf enhanced                        \" , & \"#set output 'bar.pdf'                             \" , & \"########################################          \" , & \"#set style data lines                             \" , & \"########################################          \" , & \"set datafile separator \"\"|\"\"                      \" , & \"set style data histogram                          \" , & \"set style histogram cluster gap 1                 \" , & \"set style fill solid border rgb \"\"black\"\"         \" , & \"set auto x                                        \" , & \"set yrange [0:*]                                  \" , & \"plot \"\"< sqlite3 sqlite1.db  & &'select name, hair, mobility, vision  from animals'\"\" \\  \" , & \"      using 2:xtic(1) title \"\"hair\"\",  \\          \" , & \"   '' using 4:xtic(1) title \"\"vision\"\", \\         \" , & \"   '' using 3:xtic(1) title \"\"mobility\"\"          \" , & \"quit                                              \" , & \"EOF                                               \" , & \" \" ] !! write ( * , ' ( a ) ' ) text call process_writeline ( text , fp , ierr ) call process_close ( fp , ierr ) write ( * , ' ( a ) ')' CLOSED THE PROCESS . RETURNING TO PROGRAM ' end program demo_M_process This example shows a routine to read the output of one command and\n then call another command to write that output to. program test implicit none call readit ( ' ls - l ' ) call writeit ( ' cat - n ' ) contains subroutine readit ( cmd ) use M_process , ONLY : process_open_read , process_readline use M_process , ONLY : streampointer , process_close ! C file pointer returned by process_open () type ( streampointer ) :: fp ! command line executed to start process character ( len = * ) :: cmd ! line of data to read ( assumed long enough to hold any input line ) character ( len = 4096 ) :: line integer ierr ! open process to read from call process_open_read ( cmd , fp , ierr ) write ( * , * ) ' READTEST : process is opened with status ' , ierr ierr = 0 do while ( ierr . eq . 0 ) ! read a line from the process call process_readline ( line , fp , ierr ) if ( ierr . ne .0 ) then write ( * , * ) ' READTEST : ierr is ' , ierr exit endif write ( * , * ) ' READTEST : line : ' //trim(line) enddo call process_close ( fp , ierr ) write ( * , * ) ' READTEST : process closed with status ' , ierr end subroutine readit ! --------------------------------------------------------------------- subroutine writeit ( cmd ) use M_process , only : process_open_write , process_writeline use M_process , only : streampointer , process_close ! C file pointer returned by process_open () type ( streampointer ) :: fp ! command line executed to start process character ( len = * ) :: cmd ! line of data to write ( assumed long enough to hold any output line ) character ( len = 4096 ) :: line integer :: ierr integer :: i ! open process to write to call process_open_write ( cmd , fp , ierr ) write ( * , * ) ' WRITETEST : process is opened ' ierr = 0 do i = 1 , 10 write ( line , ' ( \"WRITETEST: line \" , i0 ) ' ) i call process_writeline ( line , fp , ierr ) if ( ierr . lt .0 ) then write ( * , * ) ' WRITETEST : process write error ' , ierr exit endif enddo call process_close ( fp , ierr ) write ( * , * ) ' WRITETEST : process closed with status ' , ierr end subroutine writeit end program test SEE ALSO o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c)\no NAMED PIPES: mkfifo(3c), mknod(3c)\no SUBPROCESSES: fork(3c)\no OTHER: fflush(3c) AUTHOR John S. Urban LICENSE Public Domain DESCRIPTION: record-oriented Fortran I/O interface to C popen,pclose,fgets,fputs VERSION:     2.0.0, 20161105 AUTHOR:      John S. Urban Uses iso_c_binding Variables Type Visibility Attributes Name Initial logical, public :: process_debug = .false. Interfaces public        interface process_writeline private  subroutine process_writeline_scalar(writefrom, fp, ierr, trm) NAME proc ess_writeline ( 3 fm ) - [ M_process ] write to a process using a POSIX interface ( LICENSE: PD ) SYNOPSIS subroutine process_writeline ( string , fp , ierr ) character ( len = * ) :: string type ( streampointer ) :: fp integer :: ierr DESCRIPTION The M_process Fortran procedures use the ISO_C_BINDING interface to define\n   Fortran-callable versions of the C procedures popen(3c)/pclose(3c)\n   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines\n   are then used to create a simple Fortran-callable interface. A POSIX C interface is generally available but may require using a Linux\n   subwindow or an application such as CygWin on MSWindows platforms. See “M_process” for an extended description. OPTIONS string   data line to to process\nfp       C file pointer returned by process_open_*()\nierr     error flag returned.\n\n          o process_writeline(3f) : negative indicates an error\n          o process_readline(3f)  : Non-zero indicates an error\n\nmaximum character value length is currently 4096 EXAMPLES This example shows a routine to write lines to the stdin of a system process program demo_process_writeline\n   use, intrinsic :: iso_fortran_env, only : &\n      & stdin=>input_unit, &\n      & stdout=>output_unit, &\n      & stderr=>error_unit\n   use m_process ,only: process_open_write, process_writeline\n   use m_process ,only: streampointer, process_close\n   implicit none\n   type(streampointer) :: fp\n   ! line of data to write\n   character(len=4096) :: line\n   integer             :: ierr\n   integer             :: i\n     ! open process to write to\n     call process_open_write(‘cat -n’,fp,ierr)\n     write( , )’WRITETEST: process is opened with status ‘,ierr\n     ! remember C and Fortran I/O are often independent of each other\n     flush(stdout)\n     ierr=0\n     line=’xxxxxxxxxxxxxxxxxxxxxxxxxxx’\n     do i=1,10\n       ! write a line to the process\n       call process_writeline(trim(line),fp,ierr)\n       if(ierr.lt.0)then\n         write( , )’WRITETEST: ierr is ‘,ierr\n         exit\n       endif\n     enddo\n     call process_close(fp,ierr)\n     write( , )’WRITETEST: process closed with status ‘,ierr\n   end program demo_process_writeline Sample output: WRITETEST: process is opened with status            0\n  1 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  2 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  3 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  4 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  5 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  6 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  7 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  8 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n  9 xxxxxxxxxxxxxxxxxxxxxxxxxxx\n 10 xxxxxxxxxxxxxxxxxxxxxxxxxxx\nWRITETEST: process closed with status            0 SEE ALSO o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c)\no NAMED PIPES: mkfifo(3c), mknod(3c)\no SUBPROCESSES: fork(3c)\no OTHER: fflush(3c) AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: writefrom type( streampointer ), intent(in) :: fp integer, intent(out) :: ierr logical, intent(in), optional :: trm private  subroutine process_writeline_array(writefrom, fp, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: writefrom (:) type( streampointer ), intent(in) :: fp integer, intent(out) :: ierr Derived Types type, public :: streampointer Components Type Visibility Attributes Name Initial type(c_ptr), public :: handle = c_null_ptr Functions public  function process_readall (cmd, delim, ierr) result(string) syntax: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd character(len=*), intent(in), optional :: delim integer, intent(out), optional :: ierr Return Value character(len=:), allocatable assume will not run out of memory Subroutines public  subroutine process_close (fp, ierr) The M_process Fortran procedures use the ISO_C_BINDING\n   interface to define Fortran-callable versions of the C procedures\n   popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented\n   wrapper routines are then used to create a simple Fortran-callable\n   interface. Read more… Arguments Type Intent Optional Attributes Name type( streampointer ) :: fp integer, intent(out) :: ierr public  subroutine process_open_read (cmd, fp, ierr) The M_process Fortran procedures use the ISO_C_BINDING interface to define\n   Fortran-callable versions of the C procedures popen(3c)/pclose(3c)\n   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines\n   are then used to create a simple Fortran-callable interface. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd type( streampointer ), intent(out) :: fp integer, intent(out) :: ierr public  subroutine process_open_write (cmd, fp, ierr) The M_process Fortran procedures use the ISO_C_BINDING interface to define\n   Fortran-callable versions of the C procedures popen(3c)/pclose(3c)\n   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines\n   are then used to create a simple Fortran-callable interface. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd type( streampointer ), intent(out) :: fp integer, intent(out) :: ierr public  subroutine process_readline (readfrom, fp, ierr) The M_process Fortran procedures use the ISO_C_BINDING\n   interface to define Fortran-callable versions of the C procedures\n   popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented\n   wrapper routines are then used to create a simple Fortran-callable\n   interface. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: readfrom type( streampointer ), intent(in) :: fp integer, intent(out) :: ierr","tags":"","url":"module/m_process.html"},{"title":"demo_process_writeline – M_process","text":"Uses M_process iso_fortran_env Variables Type Attributes Name Initial type( streampointer ) :: fp integer :: i integer :: ierr character(len=4096) :: line Source Code program demo_process_writeline use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use m_process , only : process_open_write , process_writeline use m_process , only : streampointer , process_close implicit none type ( streampointer ) :: fp ! line of data to write character ( len = 4096 ) :: line integer :: ierr integer :: i ! open process to write to call process_open_write ( 'cat -n' , fp , ierr ) write ( * , * ) 'WRITETEST: process is opened with status ' , ierr ! remember C and Fortran I/O are often independent of each other flush ( stdout ) ierr = 0 line = 'xxxxxxxxxxxxxxxxxxxxxxxxxxx' do i = 1 , 10 ! write a line to the process call process_writeline ( trim ( line ), fp , ierr ) if ( ierr . lt . 0 ) then write ( * , * ) 'WRITETEST: ierr is ' , ierr exit endif enddo call process_close ( fp , ierr ) write ( * , * ) 'WRITETEST: process closed with status ' , ierr end program demo_process_writeline","tags":"","url":"program/demo_process_writeline.html"},{"title":"demo_process_open_write – M_process","text":"Uses M_process iso_fortran_env Variables Type Attributes Name Initial type( streampointer ) :: fp integer :: i integer :: ierr character(len=4096) :: line Source Code program demo_process_open_write use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use M_process , ONLY : process_open_write , process_writeline use M_process , ONLY : streampointer , process_close implicit none type ( streampointer ) :: fp ! line of data to write character ( len = 4096 ) :: line integer :: ierr integer :: i ! open process to write to call process_open_write ( 'cat -n' , fp , ierr ) write ( stdout , * ) 'OPENWTEST: process is opened with status ' , ierr ! remember C and Fortran I/O are often independent of each other flush ( stdout ) ierr = 0 line = 'xxxxxxxxxxxxxxxxxxxxxxxxxxx' do i = 1 , 10 ! write a line to the process call process_writeline ( trim ( line ), fp , ierr ) if ( ierr . lt . 0 ) then write ( stdout , * ) 'OPENWTEST: ierr is ' , ierr exit endif enddo call process_close ( fp , ierr ) write ( stdout , * ) 'OPENWTEST: process closed with status ' , ierr end program demo_process_open_write","tags":"","url":"program/demo_process_open_write.html"},{"title":"demo_M_process – M_process","text":"Uses M_process write(*,’(a)’)text Variables Type Attributes Name Initial type( streampointer ) :: fp integer :: ierr character(len=:), allocatable :: text (:) call process_open_write(‘cat’,fp,ierr) Source Code program demo_M_process use M_process , only : process_open_write , process_writeline use M_process , only : streampointer , process_close implicit none ! C file pointer returned by process_open() type ( streampointer ) :: fp ! check status of calls to process module routines integer :: ierr character ( len = :), allocatable :: text (:) ! open process to write to (ie. start gnuplot(1) program) !!call process_open_write('cat',fp,ierr) ! open process to write to (ie. start gnuplot(1) program) call process_open_write ( 'bash' , fp , ierr ) text = [ character ( len = 128 ) :: & \"rm -f sqlite1.db\" , & \"sqlite3 sqlite1.db <<\\EOF\" , & \"-- ***********************************************\" ,& \"CREATE TABLE IF NOT EXISTS animals(               \" ,& \"   name        TEXT   NOT NULL   PRIMARY KEY ,    \" ,& \"   hair        INT    NOT NULL   ,                \" ,& \"   mobility    INT    NOT NULL   ,                \" ,& \"   vision      INT    NOT NULL   );               \" ,& \"-- ***********************************************\" ,& \"INSERT INTO animals(& &name,hair,mobility,vision) VALUES('kittens',4,5,1);\" ,& \"INSERT INTO animals(& &name,hair,mobility,vision) VALUES('mice'   ,6,7,2);\" ,& \"INSERT INTO animals(& &name,hair,mobility,vision) VALUES('rats'   ,2,3,3);\" ,& \"-- ***********************************************\" ,& \".quit\" , & \"EOF\" , & \"##################################################\" ,& \"sqlite3 -header -column sqlite1.db  'select * from animals'\" ,& \"sqlite3 sqlite1.db  & &'select name, hair, mobility, vision from animals'\" ,& \"##################################################\" ,& \"gnuplot --persist <<\\EOF                          \" ,& \"########################################          \" ,& \"#set terminal gif                                 \" ,& \"#set output 'M_process.3.gif'                     \" ,& \"########################################          \" ,& \"#set terminal png                                 \" ,& \"#set output 'bar.png'                             \" ,& \"########################################          \" ,& \"#set terminal pdf enhanced                        \" ,& \"#set output 'bar.pdf'                             \" ,& \"########################################          \" ,& \"#set style data lines                             \" ,& \"########################################          \" ,& \"set datafile separator \"\"|\"\"                      \" ,& \"set style data histogram                          \" ,& \"set style histogram cluster gap 1                 \" ,& \"set style fill solid border rgb \"\"black\"\"         \" ,& \"set auto x                                        \" ,& \"set yrange [0:*]                                  \" ,& \"plot \"\"< sqlite3 sqlite1.db  & &'select name, hair, mobility, vision  from animals'\"\" \\  \" , & \"      using 2:xtic(1) title \"\"hair\"\",  \\          \" ,& \"   '' using 4:xtic(1) title \"\"vision\"\", \\         \" ,& \"   '' using 3:xtic(1) title \"\"mobility\"\"          \" ,& \"quit                                              \" ,& \"EOF                                               \" ,& \" \" ] !!write(*,'(a)')text call process_writeline ( text , fp , ierr ) call process_close ( fp , ierr ) write ( * , '(a)' ) 'CLOSED THE PROCESS. RETURNING TO PROGRAM' end program demo_M_process","tags":"","url":"program/demo_m_process.html"},{"title":"backwords – M_process","text":"Uses M_process Variables Type Attributes Name Initial character(len=4096) :: command integer :: i integer :: ierr character(len=:), allocatable :: string Source Code program backwords use M_process , only : process_readall implicit none integer :: ierr integer :: i character ( len = :), allocatable :: string character ( len = 4096 ) :: command write ( * , '(a)' , advance = 'no' ) 'Enter command to read output from:' read ( * , '(a)' ) command ! NOTE: the file is being read into memory. Doing this with a !       large file would use an excessive amount of memory. string = process_readall ( command , delim = NEW_LINE ( \"A\" ), ierr = ierr ) ! parse on newline character and process the data ! using routines like split(3f) from M_strings(3fm) or in ! this case, just echo it back reversed write ( * , '(a)' ) 'BACKWARDS' write ( * , '(*(a))' , advance = 'no' )( string ( i : i ), i = len ( string ), 1 , - 1 ) write ( * , '(a)' ) write ( * , * ) 'FORWARDS' write ( * , '(a)' , advance = 'no' ) string end program backwords","tags":"","url":"program/backwords.html"},{"title":"gnuplotexample – M_process","text":"Uses M_process iso_fortran_env Variables Type Attributes Name Initial type( streampointer ) :: fp integer :: i integer :: j integer, parameter :: n = 300 real :: x (n) real :: y (n) Subroutines subroutine plotit (step) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: step Source Code program gnuplotexample use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use m_process , only : process_open_write , process_writeline use m_process , only : streampointer , process_close implicit none integer :: i , j integer , parameter :: n = 300 real :: x ( n ) , y ( n ) type ( streampointer ) :: fp call plotit ( 'start' ) do j = 1 , 3000 , 1 do i = 1 , n ! set x() values as whole numbers 1 to n x ( i ) = i y ( i ) = sin ( x ( i ) / 2 5.0 + j / 4 0.0 ) enddo call plotit () ! plot the values in <x,y> enddo call plotit ( 'end' ) contains subroutine plotit ( step ) character ( len =* ), intent ( in ), optional :: step character ( len = 10 ) :: step_local character ( len = 80 ) :: line character ( len =* ), parameter :: g = '(*(g0,1x))' integer :: ierr integer :: i if ( present ( step )) then select case ( step ) case ( 'start' ) call process_open_write ( 'gnuplot --persist' , fp , ierr ) write ( stdout , * ) 'WRITETEST: process is opened with status ' , ierr call process_writeline ( [ character ( len = 80 ) :: & 'set terminal X11' ,& 'set nokey' ,& 'set title \" example of gnuplot data and command file generation\"' ],& fp , ierr ) case ( 'stop' ) call process_close ( fp , ierr ) write ( * , * ) 'WRITETEST: process closed with status ' , ierr end select else call process_writeline ( '$set1 <<eod' , fp , ierr ) ierr = 0 do i = 1 , n write ( line , g ) ' ' , x ( i ) , y ( i ) !x! write the x,y array as coordinates to be plotted. call process_writeline ( trim ( line ), fp , ierr ) if ( ierr . lt . 0 ) then write ( * , * ) 'WRITETEST: ierr is ' , ierr exit endif enddo call process_writeline ( 'eod' , fp , ierr ) call process_writeline ( 'plot $set1 with lines lw 4' , fp , ierr ) endif end subroutine plotit end program gnuplotexample","tags":"","url":"program/gnuplotexample.html"},{"title":"demo_process_open_read – M_process","text":"Uses M_process Variables Type Attributes Name Initial type( streampointer ) :: fp integer :: ierr character(len=4096) :: line Source Code program demo_process_open_read use M_process , ONLY : process_open_read , process_readline use M_process , ONLY : streampointer , process_close implicit none type ( streampointer ) :: fp ! line of data to read (assumed long enough to hold any output line) character ( len = 4096 ) :: line integer :: ierr ! open process to read from call process_open_read ( 'ls -l' , fp , ierr ) write ( * , * ) 'READTEST: process is opened with status ' , ierr ierr = 0 do while ( ierr . eq . 0 ) ! read a line from the process call process_readline ( line , fp , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'READTEST: ierr is ' , ierr exit endif write ( * , * ) 'READTEST: ' , trim ( line ) enddo call process_close ( fp , ierr ) write ( * , * ) 'READTEST: process closed with status ' , ierr end program demo_process_open_read","tags":"","url":"program/demo_process_open_read.html"},{"title":"demo_process_close – M_process","text":"Uses M_process Variables Type Attributes Name Initial type( streampointer ) :: fp integer :: ierr Source Code program demo_process_close use M_process , ONLY : process_open_read , process_open_write use M_process , ONLY : streampointer , process_close implicit none type ( streampointer ) :: fp integer :: ierr ! open process to read from call process_open_read ( 'ls -l' , fp , ierr ) write ( * , * ) 'CLOSE   : process is opened with status ' , ierr call process_close ( fp , ierr ) write ( * , * ) 'CLOSE   : process closed with status ' , ierr end program demo_process_close","tags":"","url":"program/demo_process_close.html"},{"title":"demo_process_readline – M_process","text":"Uses M_process Variables Type Attributes Name Initial type( streampointer ) :: fp integer :: ierr character(len=4096) :: line Source Code program demo_process_readline use M_process , ONLY : process_open_read , process_readline use M_process , ONLY : streampointer , process_close implicit none type ( streampointer ) :: fp ! line of data to read (assumed long enough to hold any output line) character ( len = 4096 ) :: line integer :: ierr ! open process to read from call process_open_read ( 'ls -l' , fp , ierr ) write ( * , * ) 'READLINE: process is opened with status ' , ierr ierr = 0 do while ( ierr . eq . 0 ) ! read a line from the process call process_readline ( line , fp , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'READLINE: ierr is ' , ierr exit endif write ( * , * ) 'READLINE: ' , trim ( line ) enddo call process_close ( fp , ierr ) write ( * , * ) 'READLINE: process closed with status ' , ierr end program demo_process_readline","tags":"","url":"program/demo_process_readline.html"},{"title":"demo_process_readall – M_process","text":"Uses M_process Variables Type Attributes Name Initial integer :: ierr character(len=:), allocatable :: string Source Code program demo_process_readall use M_process , only : process_readall implicit none integer :: ierr character ( len = :), allocatable :: string string = process_readall ( 'ls' , ierr = ierr ) write ( * , * ) ierr , string end program demo_process_readall","tags":"","url":"program/demo_process_readall.html"},{"title":"runtest – M_process","text":"Uses M_framework__verify M_framework__msg Interfaces interface subroutine test_suite_M_process() Arguments None Source Code program runtest use M_framework__msg use :: M_framework__verify , only : unit_check_level use :: M_framework__verify , only : unit_check_stop implicit none !external test_suite_M_process interface ; subroutine test_suite_M_process (); end ; end interface unit_check_level = 0 call test_suite_M_process () call unit_check_stop () contains end program runtest","tags":"","url":"program/runtest.html"},{"title":"demo_process_writeline.f90 – M_process","text":"Source Code program demo_process_writeline use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use m_process , only : process_open_write , process_writeline use m_process , only : streampointer , process_close implicit none type ( streampointer ) :: fp ! line of data to write character ( len = 4096 ) :: line integer :: ierr integer :: i ! open process to write to call process_open_write ( 'cat -n' , fp , ierr ) write ( * , * ) 'WRITETEST: process is opened with status ' , ierr ! remember C and Fortran I/O are often independent of each other flush ( stdout ) ierr = 0 line = 'xxxxxxxxxxxxxxxxxxxxxxxxxxx' do i = 1 , 10 ! write a line to the process call process_writeline ( trim ( line ), fp , ierr ) if ( ierr . lt . 0 ) then write ( * , * ) 'WRITETEST: ierr is ' , ierr exit endif enddo call process_close ( fp , ierr ) write ( * , * ) 'WRITETEST: process closed with status ' , ierr end program demo_process_writeline","tags":"","url":"sourcefile/demo_process_writeline.f90.html"},{"title":"demo_process_open_write.f90 – M_process","text":"Source Code program demo_process_open_write use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use M_process , ONLY : process_open_write , process_writeline use M_process , ONLY : streampointer , process_close implicit none type ( streampointer ) :: fp ! line of data to write character ( len = 4096 ) :: line integer :: ierr integer :: i ! open process to write to call process_open_write ( 'cat -n' , fp , ierr ) write ( stdout , * ) 'OPENWTEST: process is opened with status ' , ierr ! remember C and Fortran I/O are often independent of each other flush ( stdout ) ierr = 0 line = 'xxxxxxxxxxxxxxxxxxxxxxxxxxx' do i = 1 , 10 ! write a line to the process call process_writeline ( trim ( line ), fp , ierr ) if ( ierr . lt . 0 ) then write ( stdout , * ) 'OPENWTEST: ierr is ' , ierr exit endif enddo call process_close ( fp , ierr ) write ( stdout , * ) 'OPENWTEST: process closed with status ' , ierr end program demo_process_open_write","tags":"","url":"sourcefile/demo_process_open_write.f90.html"},{"title":"demo_M_process.f90 – M_process","text":"Source Code program demo_M_process use M_process , only : process_open_write , process_writeline use M_process , only : streampointer , process_close implicit none ! C file pointer returned by process_open() type ( streampointer ) :: fp ! check status of calls to process module routines integer :: ierr character ( len = :), allocatable :: text (:) ! open process to write to (ie. start gnuplot(1) program) !!call process_open_write('cat',fp,ierr) ! open process to write to (ie. start gnuplot(1) program) call process_open_write ( 'bash' , fp , ierr ) text = [ character ( len = 128 ) :: & \"rm -f sqlite1.db\" , & \"sqlite3 sqlite1.db <<\\EOF\" , & \"-- ***********************************************\" ,& \"CREATE TABLE IF NOT EXISTS animals(               \" ,& \"   name        TEXT   NOT NULL   PRIMARY KEY ,    \" ,& \"   hair        INT    NOT NULL   ,                \" ,& \"   mobility    INT    NOT NULL   ,                \" ,& \"   vision      INT    NOT NULL   );               \" ,& \"-- ***********************************************\" ,& \"INSERT INTO animals(& &name,hair,mobility,vision) VALUES('kittens',4,5,1);\" ,& \"INSERT INTO animals(& &name,hair,mobility,vision) VALUES('mice'   ,6,7,2);\" ,& \"INSERT INTO animals(& &name,hair,mobility,vision) VALUES('rats'   ,2,3,3);\" ,& \"-- ***********************************************\" ,& \".quit\" , & \"EOF\" , & \"##################################################\" ,& \"sqlite3 -header -column sqlite1.db  'select * from animals'\" ,& \"sqlite3 sqlite1.db  & &'select name, hair, mobility, vision from animals'\" ,& \"##################################################\" ,& \"gnuplot --persist <<\\EOF                          \" ,& \"########################################          \" ,& \"#set terminal gif                                 \" ,& \"#set output 'M_process.3.gif'                     \" ,& \"########################################          \" ,& \"#set terminal png                                 \" ,& \"#set output 'bar.png'                             \" ,& \"########################################          \" ,& \"#set terminal pdf enhanced                        \" ,& \"#set output 'bar.pdf'                             \" ,& \"########################################          \" ,& \"#set style data lines                             \" ,& \"########################################          \" ,& \"set datafile separator \"\"|\"\"                      \" ,& \"set style data histogram                          \" ,& \"set style histogram cluster gap 1                 \" ,& \"set style fill solid border rgb \"\"black\"\"         \" ,& \"set auto x                                        \" ,& \"set yrange [0:*]                                  \" ,& \"plot \"\"< sqlite3 sqlite1.db  & &'select name, hair, mobility, vision  from animals'\"\" \\  \" , & \"      using 2:xtic(1) title \"\"hair\"\",  \\          \" ,& \"   '' using 4:xtic(1) title \"\"vision\"\", \\         \" ,& \"   '' using 3:xtic(1) title \"\"mobility\"\"          \" ,& \"quit                                              \" ,& \"EOF                                               \" ,& \" \" ] !!write(*,'(a)')text call process_writeline ( text , fp , ierr ) call process_close ( fp , ierr ) write ( * , '(a)' ) 'CLOSED THE PROCESS. RETURNING TO PROGRAM' end program demo_M_process","tags":"","url":"sourcefile/demo_m_process.f90.html"},{"title":"main.f90 – M_process","text":"Source Code program backwords use M_process , only : process_readall implicit none integer :: ierr integer :: i character ( len = :), allocatable :: string character ( len = 4096 ) :: command write ( * , '(a)' , advance = 'no' ) 'Enter command to read output from:' read ( * , '(a)' ) command ! NOTE: the file is being read into memory. Doing this with a !       large file would use an excessive amount of memory. string = process_readall ( command , delim = NEW_LINE ( \"A\" ), ierr = ierr ) ! parse on newline character and process the data ! using routines like split(3f) from M_strings(3fm) or in ! this case, just echo it back reversed write ( * , '(a)' ) 'BACKWARDS' write ( * , '(*(a))' , advance = 'no' )( string ( i : i ), i = len ( string ), 1 , - 1 ) write ( * , '(a)' ) write ( * , * ) 'FORWARDS' write ( * , '(a)' , advance = 'no' ) string end program backwords","tags":"","url":"sourcefile/main.f90.html"},{"title":"M_process.f90 – M_process","text":"Source Code !> !!##NAME !!    M_process(3fm) - [M_process::INTRO] Fortran Module for calling !!                     process-related C functions from Fortran !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!     use M_process, only : process_open_read, process_open_write, process_close !! !!     use M_process, only : process_readline, process_readall, process_writeline !! !!     use M_process, only : streampointer, process_debug !! !!##DESCRIPTION !!   Module M_process(3f) lets Fortran code read/write lines from/to processes. !! !!   These Fortran procedures use the ISO_C_BINDING interface to define !!   Fortran-callable versions of the C procedures popen(3c)/pclose(3c) !!   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines !!   are then used to create a simple Fortran-callable interface. !! !!   A POSIX C interface is generally available but may require using a Linux !!   subwindow or an application such as CygWin on MSWindows platforms. !! !!   Basically, you !! !!   o Open a process for either reading from or writing to using formatted !!     sequential text records (eg. \"lines\"); much like with a regular file. !!   o pass a CHARACTER variable to/from the process that represents !!     a record. !!   o Use internal READs and internal WRITEs or parsing routines to !!     create or interpret the lines. !!   o when done close the process much like closing a file. !! !!   The procedures defined are: !! !!     ! open process to read from !!     subroutine process_open_read(cmd,fp,ierr) !! !!     ! open process to write to !!     subroutine process_open_write(cmd,fp,ierr) !! !!     ! read line from process !!     subroutine process_readline(string,fp,ierr) !!     ! read all of process output into a string string !!     function process_readall(cmd,ierr) result (string) !! !!     ! write lines to process !!     subroutine process_writeline & !!     & (string|string_array,fp,ierr[,trm=.t.|.f.]) !! !!     ! close process !!     subroutine process_close(fp,ierr) !! !!    where the variable types are !! !!       character(len=*)    :: cmd !!       type(streampointer) :: fp !!       character(len=*)    :: string !!       integer             :: ierr !! !!##OPTIONS !! !!    cmd      command passed to system to start process !!    fp       C file pointer returned by process_open_*() !!    string   data line to send or receive from process !!    ierr     error flag returned. !! !!              o process_writeline(3f) : negative indicates an error !!              o process_readline(3f)  : Non-zero indicates an error !! !!    maximum character value length is currently 4096 !! !!##EXAMPLES !! !! !! An example that places all the output of a command into a single !! string variable (see process_readall(3) for an even simpler way to !! do this) ... !! !!    program read_ex !!    use M_process ,only: process_open_read, process_readline !!    use M_process ,only: streampointer, process_close !!    implicit none !!    ! C file pointer returned by process_open() !!    type(streampointer) :: fp !!    ! check status of calls to process module routines !!    integer :: ierr !!    ! hold results, assuming sufficient memory is available !!    character(len=:),allocatable :: string !!    ! long enough to hold any expected line !!    character(len=4096) :: line !!       string='' !!       !###! open process to read from !!       call process_open_read('ls',fp,ierr) !!       !###! read output of process till end !!       do !!          call process_readline(line,fp,ierr) !!          if(ierr.ne.0)exit !!          !###! append output lines together !!          string=string//trim(line)//' ' !!          write(*,*)'['//string//']' !!       enddo !!       write(*,*)trim(string) !!       !###! Wrap up !!       call process_close(fp,ierr) !!    end program read_ex !! !! When calling a line-mode program from another program the most natural !! way is to open a process and write to it. !! !! Following is an example program that calls the M_process module to !! start a plotting program called gnuplot(1) and give it enough commands !! to generate a plot. It then lets you interactively interact with the !! gnuplot(1) program or continue on in the program. !! !!   program gnuplotExample !!   use M_process ,only: process_open_write, process_writeline !!   use M_process ,only: streampointer, process_close !!   implicit none !!   ! !!   ! Example of Fortran writing GNUPLOT command and data file. !!   ! !!   !*! line of data to write !!   !*! (assumed long enough to hold any command line) !!   character(len=4096) :: line !!   !*! C file pointer returned by process_open() !!   type(streampointer) :: fp !!   !*! check status of calls to process module routines !!   integer :: ierr !!   !*! DO loop counter !!   integer :: i !!   !*! number of points to put into curve to be plotted !!   integer,parameter   :: n=50 !!   !*! arrays to fill with curve data to be plotted !!   real                :: x(n),y(n) !!   integer             :: ios !!   !*! Define sample X,Y array. !!   do i=1,n !!   !*! set X() values as whole numbers 1 to N !!      x(i)=i !!      !*! !!      y(i)=(x(i)+0.5)**2 !!   enddo !!   !*! Write the GnuPlot commands !!   !*! open process to write to (ie. start gnuplot(1) program) !!   call process_open_write('gnuplot',fp,ierr) !!   !*! create in-line dataset $SET1 !!   call process_writeline('$SET1 <<EOD',fp,ierr) !!   do i=1,n !!      !*! Write the X,Y array as coordinates to be plotted. !!      write(line,'(2(f10.3,1x))')x(i),y(i) !!      call process_writeline(line,fp,ierr) !!   enddo !! !!   call process_writeline([character(len=128) ::                        & !!   &'EOD                                                             ', & !!   &'set title \" Example of GNUPlot data and command file generation\"', & !!   &'set nokey'                                                       , & !!   &'plot $SET1 with lines'                                           , & !!   &''],fp,ierr) !! !!   !*! Additional gnuplot commands; in this case interactively entered !!   write(*,'(a)')'enter gnuplot commands or \".\" to exit' !!   do !!      write(*,'(a)',advance='no')'gnu>>' !!      read(*,'(a)',iostat=ios)line !!      if(line.eq.'.')exit !!      call process_writeline(trim(line),fp,ierr) !!   enddo !!   !*! Wrap up !!   call process_close(fp,ierr) !!   write(*,*)'CLOSED THE PROCESS. RETURNING TO PROGRAM' !!   end program gnuplotExample !! !! This program starts a bash shell that, among other things, calls !! sqlite3 and gnuplot. In this case the text is fixed to keep the example !! simple. More typically the text would be conditionally selected or !! generated by the program. !! !!    program demo_M_process !!     use M_process ,only : process_open_write, process_writeline !!     use M_process ,only : streampointer, process_close !!     implicit none !!     ! C file pointer returned by process_open() !!     type(streampointer) :: fp !!     ! check status of calls to process module routines !!     integer :: ierr !!     character(len=:),allocatable :: text(:) !! !!     ! open process to write to (ie. start gnuplot(1) program) !!     !!call process_open_write('cat',fp,ierr) !!     ! open process to write to (ie. start gnuplot(1) program) !!     call process_open_write('bash',fp,ierr) !! !!     text=[character(len=128) :: & !!     \"rm -f sqlite1.db\", & !!     \"sqlite3 sqlite1.db <<\\EOF\", & !!     \"-- ***********************************************\",& !!     \"CREATE TABLE IF NOT EXISTS animals(               \",& !!     \"   name        TEXT   NOT NULL   PRIMARY KEY ,    \",& !!     \"   hair        INT    NOT NULL   ,                \",& !!     \"   mobility    INT    NOT NULL   ,                \",& !!     \"   vision      INT    NOT NULL   );               \",& !!     \"-- ***********************************************\",& !!     \"INSERT INTO animals(& !!     &name,hair,mobility,vision) VALUES('kittens',4,5,1);\",& !!     \"INSERT INTO animals(& !!     &name,hair,mobility,vision) VALUES('mice'   ,6,7,2);\",& !!     \"INSERT INTO animals(& !!     &name,hair,mobility,vision) VALUES('rats'   ,2,3,3);\",& !!     \"-- ***********************************************\",& !!     \".quit\", & !!     \"EOF\", & !!     \"##################################################\",& !!     \"sqlite3 -header -column sqlite1.db  'select * from animals'\",& !!     \"sqlite3 sqlite1.db  & !!     &'select name, hair, mobility, vision from animals'\",& !!     \"##################################################\",& !!     \"gnuplot --persist <<\\EOF                          \",& !!     \"########################################          \",& !!     \"#set terminal gif                                 \",& !!     \"#set output 'M_process.3.gif'                     \",& !!     \"########################################          \",& !!     \"#set terminal png                                 \",& !!     \"#set output 'bar.png'                             \",& !!     \"########################################          \",& !!     \"#set terminal pdf enhanced                        \",& !!     \"#set output 'bar.pdf'                             \",& !!     \"########################################          \",& !!     \"#set style data lines                             \",& !!     \"########################################          \",& !!     \"set datafile separator \"\"|\"\"                      \",& !!     \"set style data histogram                          \",& !!     \"set style histogram cluster gap 1                 \",& !!     \"set style fill solid border rgb \"\"black\"\"         \",& !!     \"set auto x                                        \",& !!     \"set yrange [0:*]                                  \",& !!     \"plot \"\"< sqlite3 sqlite1.db  & !!     &'select name, hair, mobility, vision  from animals'\"\" \\  \", & !!     \"      using 2:xtic(1) title \"\"hair\"\",  \\          \",& !!     \"   '' using 4:xtic(1) title \"\"vision\"\", \\         \",& !!     \"   '' using 3:xtic(1) title \"\"mobility\"\"          \",& !!     \"quit                                              \",& !!     \"EOF                                               \",& !!     \" \"] !! !!        !!write(*,'(a)')text !!        call process_writeline(text,fp,ierr) !!        call process_close(fp,ierr) !!        write(*,'(a)')'CLOSED THE PROCESS. RETURNING TO PROGRAM' !! !!     end program demo_M_process !! !! This example shows a routine to read the output of one command and !! then call another command to write that output to. !! !!      program test !!      implicit none !!        call readit('ls -l') !!        call writeit('cat -n') !!      contains !! !!      subroutine readit(cmd) !!      use M_process ,ONLY: process_open_read, process_readline !!      use M_process ,ONLY: streampointer, process_close !!      ! C file pointer returned by process_open() !!      type(streampointer) :: fp !!      ! command line executed to start process !!      character(len=*)    :: cmd !!      ! line of data to read (assumed long enough to hold any input line) !!      character(len=4096) :: line !!      integer ierr !!        ! open process to read from !!        call process_open_read(cmd,fp,ierr) !!        write(*,*)'READTEST: process is opened with status ',ierr !!        ierr=0 !!        do while(ierr .eq. 0) !!          ! read a line from the process !!          call process_readline(line,fp,ierr) !!          if(ierr.ne.0)then !!            write(*,*)'READTEST: ierr is ',ierr !!            exit !!          endif !!          write(*,*)'READTEST: line:'//trim(line) !!        enddo !!        call process_close(fp,ierr) !!        write(*,*)'READTEST: process closed with status ',ierr !!      end subroutine readit !!      !--------------------------------------------------------------------- !!      subroutine writeit(cmd) !!      use M_process, only: process_open_write, process_writeline !!      use M_process, only: streampointer, process_close !!      ! C file pointer returned by process_open() !!      type(streampointer) :: fp !!      ! command line executed to start process !!      character(len=*)    :: cmd !!      ! line of data to write (assumed long enough to hold any output line) !!      character(len=4096) :: line !!      integer             :: ierr !!      integer             :: i !!        ! open process to write to !!        call process_open_write(cmd,fp,ierr) !!        write(*,*)'WRITETEST: process is opened' !!        ierr=0 !!        do i=1,10 !!          write(line,'(\"WRITETEST: line \",i0)')i !!          call process_writeline(line,fp,ierr) !!          if(ierr.lt.0)then !!            write(*,*)'WRITETEST: process write error ',ierr !!            exit !!          endif !!        enddo !!        call process_close(fp,ierr) !!        write(*,*)'WRITETEST: process closed with status ',ierr !!      end subroutine writeit !!      end program test !! !!##SEE ALSO !!    o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) !!    o NAMED PIPES: mkfifo(3c), mknod(3c) !!    o SUBPROCESSES: fork(3c) !!    o OTHER: fflush(3c) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !> !! DESCRIPTION: record-oriented Fortran I/O interface to C popen,pclose,fgets,fputs !!##VERSION:     2.0.0, 20161105 !! AUTHOR:      John S. Urban !-============================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !-============================================================================== ! 2013/02/23  - John S. Urban module M_process ! only: c_int, c_char, c_null_char, c_associated, c_ptr, c_null_ptr, c_new_line use , intrinsic :: ISO_C_BINDING implicit none ! ident_1=\"@(#) M_process(3fm) call C process open close read write functions\" private public :: process_open_read ! (cmd,fp,ierr)     ! open process to read from public :: process_open_write ! (cmd,fp,ierr)     ! open process to write to public :: process_close ! (fp,ierr)         ! close process public :: process_readline ! (string,fp,ierr)  ! read line from process public :: process_readall ! (cmd,ierr) result(string) ! read all lines from public :: process_writeline ! (string,fp,ierr)  ! write line to process private :: process_open ! (fp,ierr)         ! open process logical , public :: process_debug = . false . type , public :: streampointer type ( c_ptr ) :: handle = c_null_ptr end type streampointer interface process_writeline module procedure process_writeline_scalar , process_writeline_array end interface !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- ! popen interface function system_popen ( path , mode ) bind ( C , name = 'popen' ) use , intrinsic :: ISO_C_BINDING character ( kind = c_char ), dimension ( * ) :: path , mode type ( c_ptr ) :: system_popen end function end interface !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- !> !!##NAME !!    fgets(3fp) - get character string from a file or stream by calling fgets(3c) !!##SYNOPSIS !! !!   #include <stdio.h> !! !!    char *fgets(char *BUF, int N, FILE *FP); !!##DESCRIPTION !!    Reads at most N-1 characters from FP until a newline is found. The !!    characters including to the newline are stored in BUF. The buffer !!    is terminated with a 0. !!##RETURNS !!    fgets(3c) returns the buffer passed to it, with the data filled !!    in. If end of file occurs with some data already accumulated, the !!    data is returned with no other indication. If no data are read, !!    NULL is returned instead. !!##PORTABILITY !!    Note that fgets(3c) returns all of the data, including the newline. ! fgets interface function system_fgets ( buf , siz , handle ) bind ( C , name = 'fgets' ) use , intrinsic :: ISO_C_BINDING type ( c_ptr ) :: system_fgets character ( kind = c_char ), dimension ( * ) :: buf integer ( kind = c_int ), value :: siz type ( c_ptr ), value :: handle end function end interface !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- ! pclose interface function system_pclose ( handle ) bind ( C , name = 'pclose' ) use , intrinsic :: ISO_C_BINDING integer ( c_int ) :: system_pclose type ( c_ptr ), value :: handle end function end interface !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- !> !!##NAME !!    fputs(3fp) - write a character string in a file or stream !!##SYNOPSIS !! !!   #include <stdio.h> !! !!    int fputs(const char *S, FILE *FP); !! !!##DESCRIPTION !!    `fputs'  writes  the string at S (but without the trailing null) to the !!    file or stream identified by FP. !!    RETURNS !!    If successful, the result is `0'; otherwise, the result is `EOF'. !!    PORTABILITY !!    ANSI  C  requires `fputs', but does not specify that the result on !!    success must be `0'; any non-negative value is permitted. interface function system_fputs ( buf , handle ) bind ( C , name = 'fputs' ) use , intrinsic :: ISO_C_BINDING integer ( c_int ) :: system_fputs character ( kind = c_char ), dimension ( * ) :: buf type ( c_ptr ), value :: handle end function end interface !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- !> !!##NAME !!    fflush(3fp) - flush buffered file output !!##SYNOPSIS !! !!    Syntax: !! !!     #include <stdio.h> !!     int fflush(FILE *FP); !!##DESCRIPTION !!    The `stdio' output functions can buffer output before delivering it !!    to the host system, in order to minimize the overhead of system calls. !! !!    Use `fflush' to deliver any such pending output (for the file or !!    stream identified by FP) to the host system. !! !!    If FP is `NULL', `fflush' delivers pending output from all open files. !! !!    Additionally, if FP is a seekable input stream visiting a file !!    descriptor, set the position of the file descriptor to match next !!    unread byte, useful for obeying POSIX semantics when ending a process !!    without consuming all input from the stream. !! !!##RETURNS !!    fflush returns '0' unless it encounters a write error; in that !!    situation, it returns `EOF'. !! !!##PORTABILITY !!    ANSI C requires `fflush'. The behavior on input streams is only !!    specified by POSIX, and not all implementations follow POSIX rules. !! !!    No supporting OS subroutines are required. interface function fflush ( handle ) bind ( C , name = 'fflush' ) use , intrinsic :: ISO_C_BINDING integer ( c_int ) :: fflush type ( c_ptr ), value :: handle end function end interface !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- contains !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- !> !!##NAME !!    process_open_read(3fm) - [M_process] open a process for reading using !!    POSIX interface !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!     subroutine process_open_read(cmd,fp,ierr) !! !!       character(len=*)    :: cmd !!       type(streampointer) :: fp !!       integer             :: ierr !! !!##DESCRIPTION !!   The M_process Fortran procedures use the ISO_C_BINDING interface to define !!   Fortran-callable versions of the C procedures popen(3c)/pclose(3c) !!   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines !!   are then used to create a simple Fortran-callable interface. !! !!   A POSIX C interface is generally available but may require using a Linux !!   subwindow or an application such as CygWin on MSWindows platforms. !! !!   See \"M_process\" for an extended description. !! !!##OPTIONS !! !!    cmd      command passed to system to start process !!    fp       C file pointer returned by process_open_*() !!    ierr     error flag returned. !! !!              o process_writeline(3f) : negative indicates an error !!              o process_readline(3f)  : Non-zero indicates an error !! !!    maximum character value length is currently 4096 !! !!##EXAMPLES !! !! !!  This example shows a routine to read the output of a system command. !! !!   program demo_process_open_read !!   use M_process ,ONLY: process_open_read, process_readline !!   use M_process ,ONLY: streampointer, process_close !!   implicit none !!   type(streampointer) :: fp !!   ! line of data to read (assumed long enough to hold any output line) !!   character(len=4096) :: line !!   integer             :: ierr !!     ! open process to read from !!     call process_open_read('ls -l',fp,ierr) !!     write(*,*)'READTEST: process is opened with status ',ierr !!     ierr=0 !!     do while(ierr .eq. 0) !!       ! read a line from the process !!       call process_readline(line,fp,ierr) !!       if(ierr.ne.0)then !!         write(*,*)'READTEST: ierr is ',ierr !!         exit !!       endif !!       write(*,*)'READTEST: ',trim(line) !!     enddo !!     call process_close(fp,ierr) !!     write(*,*)'READTEST: process closed with status ',ierr !!   end program demo_process_open_read !! !!  Sample output: !! !!   READTEST: process is opened with status            0 !!   READTEST: total 108 !!   READTEST: -rw-r--r--. 1 urbanjs urbanjs  3731 Oct 17 14:49 build.sh !!   READTEST: -rw-rw-r--. 1 urbanjs urbanjs 56633 Oct 17 14:50 build.sh.log !!   READTEST: drwxrwxr-x. 3 urbanjs urbanjs  4096 Oct 17 14:50 doc !!   READTEST: -rw-rw-r--. 1 urbanjs urbanjs 39459 Oct 17 15:16 M_process.ff !!   READTEST: -rw-rw-r--. 1 urbanjs urbanjs   826 Oct 17 15:17 xx.f90 !!   READTEST: ierr is           -1 !!   READTEST: process closed with status            0 !! !!##SEE ALSO !!    o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) !!    o NAMED PIPES: mkfifo(3c), mknod(3c) !!    o SUBPROCESSES: fork(3c) !!    o OTHER: fflush(3c) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine process_open_read ( cmd , fp , ierr ) ! ident_2=\"@(#) M_process process_open_read(3f) open process to read from\" ! shell command to start process with character ( len =* ), intent ( in ) :: cmd ! file pointer returned for process type ( streampointer ), intent ( out ) :: fp ! status for attempt to open process (0= no error) integer , intent ( out ) :: ierr ! read/write mode parameter to pass to popen(3c) character ( len = 3 ), parameter :: mode = 'r' !------------------------------------------------------------------------------- ierr = 0 call process_open ( cmd , mode , fp , ierr ) end subroutine process_open_read !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- !> !!##NAME !!    process_open_write(3fm) - [M_process] open a process for writing using a !!    POSIX interface !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!     subroutine process_open_write(cmd,fp,ierr) !! !!       character(len=*)    :: cmd !!       type(streampointer) :: fp !!       integer             :: ierr !! !!##DESCRIPTION !!   The M_process Fortran procedures use the ISO_C_BINDING interface to define !!   Fortran-callable versions of the C procedures popen(3c)/pclose(3c) !!   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines !!   are then used to create a simple Fortran-callable interface. !! !!   A POSIX C interface is generally available but may require using a Linux !!   subwindow or an application such as CygWin on MSWindows platforms. !! !!   See \"M_process\" for an extended description. !! !!##OPTIONS !! !!    cmd      command passed to system to start process !!    fp       C file pointer returned by process_open_*() !!    ierr     error flag returned. !! !!              o process_writeline(3f) : negative indicates an error !!              o process_readline(3f)  : Non-zero indicates an error !! !!    maximum character value length is currently 4096 !! !!##EXAMPLES !! !! !!  This example shows a routine to write lines to the stdin of a system process !! !!   program demo_process_open_write !!   use, intrinsic :: iso_fortran_env, only : & !!   & stdin=>input_unit, & !!   & stdout=>output_unit, & !!   & stderr=>error_unit !!   use M_process ,ONLY: process_open_write, process_writeline !!   use M_process ,ONLY: streampointer, process_close !!   implicit none !!   type(streampointer) :: fp !!   ! line of data to write !!   character(len=4096) :: line !!   integer             :: ierr !!   integer             :: i !!     ! open process to write to !!     call process_open_write('cat -n',fp,ierr) !!     write(stdout,*)'OPENWTEST: process is opened with status ',ierr !!     ! remember C and Fortran I/O are often independent of each other !!     flush(stdout) !!     ierr=0 !!     line='xxxxxxxxxxxxxxxxxxxxxxxxxxx' !!     do i=1,10 !!       ! write a line to the process !!       call process_writeline(trim(line),fp,ierr) !!       if(ierr.lt.0)then !!         write(stdout,*)'OPENWTEST: ierr is ',ierr !!         exit !!       endif !!     enddo !!     call process_close(fp,ierr) !!     write(stdout,*)'OPENWTEST: process closed with status ',ierr !!   end program demo_process_open_write !! !!  Sample output: !! !!   >OPENWTEST: process is opened with status            0 !!   >    1        xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >    2        xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >    3        xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >    4        xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >    5        xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >    6        xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >    7        xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >    8        xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >    9        xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >   10        xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >OPENWTEST: process closed with status            0 !! !!##SEE ALSO !!    o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) !!    o NAMED PIPES: mkfifo(3c), mknod(3c) !!    o SUBPROCESSES: fork(3c) !!    o OTHER: fflush(3c) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine process_open_write ( cmd , fp , ierr ) ! ident_3=\"@(#) M_process process_open_write(3f) open process to write to\" ! shell command to start process with character ( len =* ), intent ( in ) :: cmd ! file pointer returned for process type ( streampointer ), intent ( out ) :: fp ! status for attempt to open process (0= no error) integer , intent ( out ) :: ierr ! read/write mode parameter to pass to popen(3c) character ( len = 3 ), parameter :: mode = 'w' !------------------------------------------------------------------------------- ierr = 0 call process_open ( cmd , mode , fp , ierr ) end subroutine process_open_write !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- !> !!##NAME !!    (LICENSE:PD) !!##SYNOPSIS !! !!##DESCRIPTION !!##EXAMPLE !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine process_open ( cmd , mode , fp , ierr ) ! ident_4=\"@(#) M_process process_open(3fp) open process\" ! shell command to start process with character ( len =* ), intent ( in ) :: cmd ! read/write/mode parameter to pass to popen(3c) character ( len =* ), intent ( in ) :: mode ! file pointer returned for process type ( streampointer ), intent ( out ) :: fp ! status for attempt to open process (0= no error) integer , intent ( out ) :: ierr !------------------------------------------------------------------------------- ierr = 0 fp % handle = system_popen ( trim ( cmd ) // C_NULL_CHAR , trim ( mode ) // C_NULL_CHAR ) if (. not . c_associated ( fp % handle )) then write ( * , * ) '*process_open_write* ERROR: Could not open pipe!' ierr =- 1 else if ( process_debug ) then write ( * , * ) '*process_open_write* Opened pipe successfully' endif endif end subroutine process_open !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- !> !!##NAME !!    process_close(3fm) - [M_process] close a process being written to !!    or read from !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!     subroutine process_close(fp,ierr) !! !!       type(streampointer) :: fp !!       integer             :: ierr !! !!##DESCRIPTION !!   The M_process Fortran procedures use the ISO_C_BINDING !!   interface to define Fortran-callable versions of the C procedures !!   popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented !!   wrapper routines are then used to create a simple Fortran-callable !!   interface. !! !!   A POSIX C interface is generally available but may require using a !!   Linux subwindow or an application such as CygWin on MSWindows platforms. !! !!   See \"M_process\" for an extended description. !! !!##OPTIONS !! !!    fp       C file pointer returned by process_open_*() !!    ierr     error flag returned. !! !!##EXAMPLES !! !! !!  This example shows a simple open and close of a process !! !!   program demo_process_close !!   use M_process ,ONLY: process_open_read, process_open_write !!   use M_process ,ONLY: streampointer, process_close !!   implicit none !!   type(streampointer) :: fp !!   integer             :: ierr !!     ! open process to read from !!     call process_open_read('ls -l',fp,ierr) !!     write(*,*)'CLOSE   : process is opened with status ',ierr !!     call process_close(fp,ierr) !!     write(*,*)'CLOSE   : process closed with status ',ierr !!   end program demo_process_close !! !!  Sample output: !! !!     CLOSE   : process is opened with status            0 !!     CLOSE   : process closed with status           13 !! !!##SEE ALSO !!    o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) !!    o NAMED PIPES: mkfifo(3c), mknod(3c) !!    o SUBPROCESSES: fork(3c) !!    o OTHER: fflush(3c) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine process_close ( fp , ierr ) ! ident_5=\"@(#) M_process process_close(3f) close process\" ! file pointer returned for process ! DO NOT MAKE fp INTENT(IN) type ( streampointer ) :: fp integer ( c_int ) :: ios integer , intent ( out ) :: ierr !------------------------------------------------------------------------------- ios = 0_c_int if (. not . c_associated ( fp % handle )) then write ( * , * ) '*process_close* process not found' else ios = fflush ( fp % handle ) if ( ierr . ge . 0 ) then ios = system_pclose ( fp % handle ) endif endif if ( process_debug ) then write ( * , * ) '*process_close* Closed pipe with status ' , ios endif ierr = ios end subroutine process_close !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- !> !!##NAME !!    process_readline(3fm) - [M_process] read a line of output from !!    a system command as a character variable !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!     subroutine process_readline(string,fp,ierr) !! !!       character(len=*)    :: string !!       type(streampointer) :: fp !!       integer             :: ierr !! !!##DESCRIPTION !!   The M_process Fortran procedures use the ISO_C_BINDING !!   interface to define Fortran-callable versions of the C procedures !!   popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented !!   wrapper routines are then used to create a simple Fortran-callable !!   interface. !! !!   A POSIX C interface is generally available but may require using a !!   Linux subwindow or an application such as CygWin on MSWindows platforms. !! !!   See \"M_process\" for an extended description. !! !!##OPTIONS !! !!    string   data line to receive from process !!    fp       C file pointer returned by process_open_*() !!    ierr     error flag returned. !! !!              o process_writeline(3f) : negative indicates an error !!              o process_readline(3f)  : Non-zero indicates an error !! !!    maximum character value length is currently 4096 !! !!##EXAMPLES !! !! !!  This example shows a routine reading the output of a system command. !! !!   program demo_process_readline !!   use M_process ,ONLY: process_open_read, process_readline !!   use M_process ,ONLY: streampointer, process_close !!   implicit none !!   type(streampointer) :: fp !!   ! line of data to read (assumed long enough to hold any output line) !!   character(len=4096) :: line !!   integer             :: ierr !!     ! open process to read from !!     call process_open_read('ls -l',fp,ierr) !!     write(*,*)'READLINE: process is opened with status ',ierr !!     ierr=0 !!     do while(ierr .eq. 0) !!       ! read a line from the process !!       call process_readline(line,fp,ierr) !!       if(ierr.ne.0)then !!         write(*,*)'READLINE: ierr is ',ierr !!         exit !!       endif !!       write(*,*)'READLINE: ',trim(line) !!     enddo !!     call process_close(fp,ierr) !!     write(*,*)'READLINE: process closed with status ',ierr !!   end program demo_process_readline !! !!  Sample output: !! !!   READLINE: process is opened with status            0 !!   READLINE: total 108 !!   READLINE: -rw-r--r--. 1 urbanjs urbanjs  3731 Oct 17 14:49 build.sh !!   READLINE: -rw-rw-r--. 1 urbanjs urbanjs 56633 Oct 17 14:50 build.sh.log !!   READLINE: drwxrwxr-x. 3 urbanjs urbanjs  4096 Oct 17 14:50 doc !!   READLINE: -rw-rw-r--. 1 urbanjs urbanjs 39459 Oct 17 15:16 M_process.ff !!   READLINE: -rw-rw-r--. 1 urbanjs urbanjs   826 Oct 17 15:17 xx.f90 !!   READLINE: ierr is           -1 !!   READLINE: process closed with status            0 !! !!##SEE ALSO !!    o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) !!    o NAMED PIPES: mkfifo(3c), mknod(3c) !!    o SUBPROCESSES: fork(3c) !!    o OTHER: fflush(3c) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine process_readline ( readfrom , fp , ierr ) ! ident_6=\"@(#) M_process process_readline(3f) read line from process\" ! readfrom length must be at least two character ( len =* ), intent ( out ) :: readfrom type ( streampointer ), intent ( in ) :: fp integer , intent ( out ) :: ierr integer ( kind = c_int ) :: clen integer :: eos , i integer :: ios clen = len ( readfrom ) - 1 readfrom = ' ' do while ( c_associated ( system_fgets ( readfrom , clen , fp % handle ))) eos = 2 do i = 1 , clen if ( readfrom ( i : i ) == C_NULL_CHAR ) then eos = i - 2 ! assuming line terminator character and ! line string terminator should not be printed readfrom ( eos + 1 :) = ' ' exit endif enddo if ( process_debug ) then write ( * , * ) eos , ': \"' , trim ( readfrom ( 1 : eos )), '\"' endif ierr = 0 return end do ! an error occurred ios = 0 !!ios = system_pclose(fp%handle) !!if(process_debug)then !!   write(*,*) '*process_readline* Closed pipe with status ',ios !!endif ierr = min ( - 1 , ios ) end subroutine process_readline !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- !> !!##NAME !!    process_readall(3f) - [M_process] read all lines from process into !!    single string !!    (LICENSE:PD) !!##SYNOPSIS !! !!   syntax: !! !!    function process_readall(cmd,delim,ierr)  result(string) !! !!       character(len=*),intent(in)              :: cmd !!       character(len=*),intent(in),optional     :: delim !!       integer,intent(out),optional             :: ierr !!       character(len=:),allocatable             :: string !!##OPTIONS !!       cmd        command to pass to system !!       delim      delimiter to place between output lines when they !!                  are concatenated. Defaults to a space !!       ierr       check status of call. !!##RESULTS !!       process_readall   Assuming sufficient memory is available all the !!                         output of the system command are concatenated !!                         into a string with spaces added between the !!                         output lines of the command. !!##EXAMPLE !! !! !!   Read all output of a command to a single string !! !!     program demo_process_readall !!      use M_process, only: process_readall !!      implicit none !!      integer :: ierr !!      character(len=:),allocatable :: string !!          string=process_readall('ls',ierr=ierr) !!          write(*,*)ierr,string !!      end program demo_process_readall !! !!   Results: !! !!    app build docs example fpm.toml LICENSE man README.md src test !! !!   Read all output of a command to an array using split(3f) !! !!      program test_process_readall !!       use M_process ,only: process_readall !!       use M_strings ,only: split !!       implicit none !!       integer                      :: ierr !!       integer                      :: i !!       character(len=:),allocatable :: string !!       character(len=:),allocatable :: array(:) !!          string=process_readall('ls',delim=NEW_LINE(\"A\"),ierr=ierr) !!          call split(string,array,delimiters=NEW_LINE(\"A\")) !!          do i=1,size(array) !!             write(*,'(i0,t10,\"[\",a,\"]\")')i,trim(array(i)) !!          enddo !!          write(*,*)string=process_readall(& !!          & 'ls',delim=NEW_LINE(\"A\"),ierr=ierr) !!          write(*,*)string !!       end program test_process_readall !! !!   Results: !! !!       > 1     [Articles] !!       > 2     [LIBRARY] !!       > 3     [PC] !!       > 4     [SHIP] !!       > 5     [SPEC] !!       > 6     [crib.dat] !!       > 7     [doc] !!       > 8     [html] !!       > 9     [index.html] !!       > 10    [plan.txt] !!       > 11    [questions] !!       > 12    [scripts] !!       > 13    [tmp] !! !!##SEE ALSO !!    M_process(3fm) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain function process_readall ( cmd , delim , ierr ) result ( string ) !! not hardened ! ident_7=\"@(#) M_process process_readall(3f) read all lines from process\" character ( len =* ), intent ( in ) :: cmd character ( len = :), allocatable :: string !! assume will not run out of memory character ( len =* ), intent ( in ), optional :: delim integer , intent ( out ), optional :: ierr character ( len = :), allocatable :: delim_local integer :: ierr_local ( 3 ), ierr_read integer :: i type ( streampointer ) :: fp character ( len = 4096 ) :: line !! assumed long enough !------------------------------------------------------------------------------- if ( present ( delim )) then delim_local = delim else delim_local = ' ' endif !! change to stream I/O so do not have to have arbitrary line length limit, !! or at least make length an option string = '' ierr_local (:) = 0 call process_open_read ( cmd , fp , ierr_local ( 1 )) ! start command if ( ierr_local ( 1 ). eq . 0 ) then do ! read line from command output call process_readline ( line , fp , ierr_read ) if ( ierr_read . ne . 0 ) then exit endif string = string // trim ( line ) // delim_local enddo string = trim ( string ) endif call process_close ( fp , ierr_local ( 3 )) ! Wrap up if ( present ( ierr )) then do i = 1 , size ( ierr_local ) if ( ierr_local ( i ). ne . 0 ) then ierr = ierr_local ( i ) exit endif enddo elseif ( any ( ierr_local . ne . 0 )) then !!write(*,*)'*M_process::process_readall(3f)* error values=',ierr_local stop \"*M_process::process_readall(3f)* error\" endif end function process_readall !------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !------------------------------------------------------------------------------- !> !!##NAME !!    process_writeline(3fm) - [M_process] write to a process using a !!                             POSIX interface !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!     subroutine process_writeline(string,fp,ierr) !! !!       character(len=*)    :: string !!       type(streampointer) :: fp !!       integer             :: ierr !! !!##DESCRIPTION !!   The M_process Fortran procedures use the ISO_C_BINDING interface to define !!   Fortran-callable versions of the C procedures popen(3c)/pclose(3c) !!   and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines !!   are then used to create a simple Fortran-callable interface. !! !!   A POSIX C interface is generally available but may require using a Linux !!   subwindow or an application such as CygWin on MSWindows platforms. !! !!   See \"M_process\" for an extended description. !! !!##OPTIONS !! !!    string   data line to to process !!    fp       C file pointer returned by process_open_*() !!    ierr     error flag returned. !! !!              o process_writeline(3f) : negative indicates an error !!              o process_readline(3f)  : Non-zero indicates an error !! !!    maximum character value length is currently 4096 !! !!##EXAMPLES !! !! !!  This example shows a routine to write lines to the stdin of a system process !! !!   program demo_process_writeline !!   use, intrinsic :: iso_fortran_env, only : & !!      & stdin=>input_unit, & !!      & stdout=>output_unit, & !!      & stderr=>error_unit !!   use m_process ,only: process_open_write, process_writeline !!   use m_process ,only: streampointer, process_close !!   implicit none !!   type(streampointer) :: fp !!   ! line of data to write !!   character(len=4096) :: line !!   integer             :: ierr !!   integer             :: i !!     ! open process to write to !!     call process_open_write('cat -n',fp,ierr) !!     write(*,*)'WRITETEST: process is opened with status ',ierr !!     ! remember C and Fortran I/O are often independent of each other !!     flush(stdout) !!     ierr=0 !!     line='xxxxxxxxxxxxxxxxxxxxxxxxxxx' !!     do i=1,10 !!       ! write a line to the process !!       call process_writeline(trim(line),fp,ierr) !!       if(ierr.lt.0)then !!         write(*,*)'WRITETEST: ierr is ',ierr !!         exit !!       endif !!     enddo !!     call process_close(fp,ierr) !!     write(*,*)'WRITETEST: process closed with status ',ierr !!   end program demo_process_writeline !! !!  Sample output: !! !!   >WRITETEST: process is opened with status            0 !!   >   1 xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >   2 xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >   3 xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >   4 xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >   5 xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >   6 xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >   7 xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >   8 xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >   9 xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >  10 xxxxxxxxxxxxxxxxxxxxxxxxxxx !!   >WRITETEST: process closed with status            0 !! !!##SEE ALSO !!    o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) !!    o NAMED PIPES: mkfifo(3c), mknod(3c) !!    o SUBPROCESSES: fork(3c) !!    o OTHER: fflush(3c) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine process_writeline_scalar ( writefrom , fp , ierr , trm ) ! ident_8=\"@(#) M_process process_writeline_scalar(3fp) write line to process\" character ( len =* ), intent ( in ) :: writefrom type ( streampointer ), intent ( in ) :: fp integer , intent ( out ) :: ierr logical , intent ( in ), optional :: trm logical :: trm_local !------------------------------------------------------------------------------- if ( present ( trm )) then trm_local = trm else trm_local = . true . endif !------------------------------------------------------------------------------- if ( trm_local ) then ierr = system_fputs ( trim ( writefrom ) // C_NEW_LINE // C_NULL_CHAR , fp % handle ) else ierr = system_fputs ( writefrom // C_NEW_LINE // C_NULL_CHAR , fp % handle ) endif !------------------------------------------------------------------------------- if ( ierr . lt . 0 ) then if ( process_debug ) then write ( * , * ) '*process_writeline_scalar* Closed pipe with status ' , ierr endif endif !------------------------------------------------------------------------------- if ( ierr . eq . 0 ) then ierr = fflush ( fp % handle ) endif !------------------------------------------------------------------------------- end subroutine process_writeline_scalar subroutine process_writeline_array ( writefrom , fp , ierr ) ! ident_9=\"@(#) M_process process_writeline_array(3fp) write lines to process\" character ( len =* ), intent ( in ) :: writefrom (:) type ( streampointer ), intent ( in ) :: fp integer , intent ( out ) :: ierr integer :: i integer :: isize !------------------------------------------------------------------------------- isize = size ( writefrom , dim = 1 ) if ( process_debug ) then write ( * , * ) '*process_writeline_array*' , isize endif ierr = 0 do i = 1 , size ( writefrom , dim = 1 ) call process_writeline_scalar ( writefrom ( i ), fp , ierr ) if ( ierr . lt . 0 ) exit enddo if ( i . ne . isize + 1 ) then write ( * , * ) '*process_writeline_array* only processed' ,& & i , ' of ' , isize , ' elements' endif end subroutine process_writeline_array !=============================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=============================================================================== end module M_process !-============================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !-==============================================================================","tags":"","url":"sourcefile/m_process.f90.html"},{"title":"gnuplot_example.f90 – M_process","text":"Source Code program gnuplotexample use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use m_process , only : process_open_write , process_writeline use m_process , only : streampointer , process_close implicit none integer :: i , j integer , parameter :: n = 300 real :: x ( n ) , y ( n ) type ( streampointer ) :: fp call plotit ( 'start' ) do j = 1 , 3000 , 1 do i = 1 , n ! set x() values as whole numbers 1 to n x ( i ) = i y ( i ) = sin ( x ( i ) / 2 5.0 + j / 4 0.0 ) enddo call plotit () ! plot the values in <x,y> enddo call plotit ( 'end' ) contains subroutine plotit ( step ) character ( len =* ), intent ( in ), optional :: step character ( len = 10 ) :: step_local character ( len = 80 ) :: line character ( len =* ), parameter :: g = '(*(g0,1x))' integer :: ierr integer :: i if ( present ( step )) then select case ( step ) case ( 'start' ) call process_open_write ( 'gnuplot --persist' , fp , ierr ) write ( stdout , * ) 'WRITETEST: process is opened with status ' , ierr call process_writeline ( [ character ( len = 80 ) :: & 'set terminal X11' ,& 'set nokey' ,& 'set title \" example of gnuplot data and command file generation\"' ],& fp , ierr ) case ( 'stop' ) call process_close ( fp , ierr ) write ( * , * ) 'WRITETEST: process closed with status ' , ierr end select else call process_writeline ( '$set1 <<eod' , fp , ierr ) ierr = 0 do i = 1 , n write ( line , g ) ' ' , x ( i ) , y ( i ) !x! write the x,y array as coordinates to be plotted. call process_writeline ( trim ( line ), fp , ierr ) if ( ierr . lt . 0 ) then write ( * , * ) 'WRITETEST: ierr is ' , ierr exit endif enddo call process_writeline ( 'eod' , fp , ierr ) call process_writeline ( 'plot $set1 with lines lw 4' , fp , ierr ) endif end subroutine plotit end program gnuplotexample","tags":"","url":"sourcefile/gnuplot_example.f90.html"},{"title":"demo_process_open_read.f90 – M_process","text":"Source Code program demo_process_open_read use M_process , ONLY : process_open_read , process_readline use M_process , ONLY : streampointer , process_close implicit none type ( streampointer ) :: fp ! line of data to read (assumed long enough to hold any output line) character ( len = 4096 ) :: line integer :: ierr ! open process to read from call process_open_read ( 'ls -l' , fp , ierr ) write ( * , * ) 'READTEST: process is opened with status ' , ierr ierr = 0 do while ( ierr . eq . 0 ) ! read a line from the process call process_readline ( line , fp , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'READTEST: ierr is ' , ierr exit endif write ( * , * ) 'READTEST: ' , trim ( line ) enddo call process_close ( fp , ierr ) write ( * , * ) 'READTEST: process closed with status ' , ierr end program demo_process_open_read","tags":"","url":"sourcefile/demo_process_open_read.f90.html"},{"title":"demo_process_close.f90 – M_process","text":"Source Code program demo_process_close use M_process , ONLY : process_open_read , process_open_write use M_process , ONLY : streampointer , process_close implicit none type ( streampointer ) :: fp integer :: ierr ! open process to read from call process_open_read ( 'ls -l' , fp , ierr ) write ( * , * ) 'CLOSE   : process is opened with status ' , ierr call process_close ( fp , ierr ) write ( * , * ) 'CLOSE   : process closed with status ' , ierr end program demo_process_close","tags":"","url":"sourcefile/demo_process_close.f90.html"},{"title":"demo_process_readline.f90 – M_process","text":"Source Code program demo_process_readline use M_process , ONLY : process_open_read , process_readline use M_process , ONLY : streampointer , process_close implicit none type ( streampointer ) :: fp ! line of data to read (assumed long enough to hold any output line) character ( len = 4096 ) :: line integer :: ierr ! open process to read from call process_open_read ( 'ls -l' , fp , ierr ) write ( * , * ) 'READLINE: process is opened with status ' , ierr ierr = 0 do while ( ierr . eq . 0 ) ! read a line from the process call process_readline ( line , fp , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'READLINE: ierr is ' , ierr exit endif write ( * , * ) 'READLINE: ' , trim ( line ) enddo call process_close ( fp , ierr ) write ( * , * ) 'READLINE: process closed with status ' , ierr end program demo_process_readline","tags":"","url":"sourcefile/demo_process_readline.f90.html"},{"title":"demo_process_readall.f90 – M_process","text":"Source Code program demo_process_readall use M_process , only : process_readall implicit none integer :: ierr character ( len = :), allocatable :: string string = process_readall ( 'ls' , ierr = ierr ) write ( * , * ) ierr , string end program demo_process_readall","tags":"","url":"sourcefile/demo_process_readall.f90.html"},{"title":"test_suite_M_process.f90 – M_process","text":"Source Code program runtest use M_framework__msg use :: M_framework__verify , only : unit_check_level use :: M_framework__verify , only : unit_check_stop implicit none !external test_suite_M_process interface ; subroutine test_suite_M_process (); end ; end interface unit_check_level = 0 call test_suite_M_process () call unit_check_stop () contains end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_suite_M_process () use M_framework__verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_process !! setup call test_process_open_read () call test_process_open_write () call test_process_readall () call test_process_readline () call test_process_writeline_array () call test_process_writeline_scalar () call test_process_close () !! teardown contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_close () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines character ( len = :), allocatable :: string ! hold results, assuming sufficient memory is available character ( len = 4096 ) :: line ! long enough to hold any expected line call unit_check_start ( 'process_close' , msg = '' ) string = '' !!call process_close(fp,ierr)             ! not open yet !!call unit_check('process_close', ierr.ne.0, 'close process before opening it',ierr) call process_open_read ( 'echo A;echo B;echo C' , fp , ierr ) ! open process to read from do ! read output of process till end call process_readline ( line , fp , ierr ) if ( ierr . ne . 0 ) exit string = string // trim ( line ) // ' ' ! append output lines together enddo call unit_check_msg ( 'process_close' , 'string=' , string ) call process_close ( fp , ierr ) ! Wrap up call unit_check ( 'process_close' , ierr . eq . 0 , 'close process ' , ierr ) call process_open_write ( 'cat' , fp , ierr ) ! open process to write to that is not terminated call process_close ( fp , ierr ) !!call unit_check('process_close', ierr.eq.0, 'close process that is open',ierr) call unit_check_done ( 'process_close' , msg = '' ) end subroutine test_process_close !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_open_read () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines character ( len = :), allocatable :: string ! hold results, assuming sufficient memory is available character ( len = 4096 ) :: line ! long enough to hold any expected line call unit_check_start ( 'process_open_read' , msg = '' ) string = '' call process_open_read ( 'echo a;echo b;echo c' , fp , ierr ) ! open process to read from call unit_check ( 'process_open_read' , ierr . eq . 0 , 'open ierr=' , ierr ) do ! read output of process till end call process_readline ( line , fp , ierr ) if ( ierr . ne . 0 ) exit string = string // trim ( line ) // '+' ! append output lines together enddo call unit_check ( 'process_open_read' , string . eq . 'a+b+c+' , string ) call process_open_read ( 'echo a;echo b;echo c' , fp , ierr ) ! open process to read from call unit_check ( 'process_open_read' , string . eq . 'a+b+c+' , 'open already open process,ierr=' , ierr ) call process_close ( fp , ierr ) ! Wrap up !!call unit_check('process_open_read', ierr.eq.0, 'close ierr=',ierr) call unit_check_done ( 'process_open_read' , msg = '' ) end subroutine test_process_open_read !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_open_write () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines integer :: lun integer :: ios character ( len = 256 ) :: line call unit_check_start ( 'process_open_write' , msg = '' ) ! clear scratch file open ( newunit = lun , file = '_scratch_.txt' , iostat = ios ) close ( unit = lun , iostat = ios , status = 'delete' ) ! start shell with command that finishes immediately (special case, would just use execute_command_line(3f) intrinsic) call process_open_write ( 'echo one >_scratch_.txt;echo two >>_scratch_.txt' , fp , ierr ) ! open process to write to call unit_check ( 'process_open_write' , ierr . eq . 0 , 'ierr=' , ierr ) call process_close ( fp , ierr ) call unit_check ( 'process_open_write' , ierr . eq . 0 , 'no error on close, ierr=' , ierr ) ! check expected file open ( newunit = lun , file = '_scratch_.txt' ) read ( lun , '(a)' , iostat = ios ) line call unit_check ( 'process_open_write' , line . eq . 'one' , 'line 1:' , line ) read ( lun , '(a)' , iostat = ios ) line call unit_check ( 'process_open_write' , line . eq . 'two' , 'line 2:' , line ) close ( unit = lun , iostat = ios , status = 'delete' ) ! start shell that waits to read commands call process_open_write ( 'bash||cmd' , fp , ierr ) ! open process to write to call unit_check ( 'process_open_write' , ierr . eq . 0 , 'ierr=' , ierr ) call process_writeline ( 'echo three >_scratch_.txt' , fp , ierr ) call unit_check ( 'process_open_write' , ierr . ge . 0 , 'write of \"echo three >_scratch_.txt\", ierr=' , ierr ) call process_writeline ( 'echo four >>_scratch_.txt' , fp , ierr ) call unit_check ( 'process_open_write' , ierr . ge . 0 , 'write of \"echo four >>_scratch_.txt\", ierr=' , ierr ) call process_close ( fp , ierr ) call unit_check ( 'process_open_write' , ierr . eq . 0 , 'should now be closed, ierr=' , ierr ) ! check expected file open ( newunit = lun , file = '_scratch_.txt' ) read ( lun , '(a)' , iostat = ios ) line call unit_check ( 'process_open_write' , line . eq . 'three' , 'line 1:' , line ) read ( lun , '(a)' , iostat = ios ) line call unit_check ( 'process_open_write' , line . eq . 'four' , 'line 2:' , line ) close ( unit = lun , iostat = ios , status = 'delete' ) ! call unit_check_done ( 'process_open_write' , msg = '' ) end subroutine test_process_open_write !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_readall () integer :: ierr character ( len = :), allocatable :: string string = process_readall ( 'echo A;echo B;echo C' , ierr = ierr ) call unit_check_start ( 'process_readall' , msg = '' ) call unit_check ( 'process_readall' , string . eq . 'A B C' , string ) call unit_check_done ( 'process_readall' , msg = '' ) end subroutine test_process_readall !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_readline () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines character ( len = :), allocatable :: string ! hold results, assuming sufficient memory is available character ( len = 4096 ) :: line ! long enough to hold any expected line call unit_check_start ( 'process_readline' , msg = '' ) string = '' call process_open_read ( 'echo a;echo b;echo c' , fp , ierr ) ! open process to read from do ! read output of process till end call process_readline ( line , fp , ierr ) if ( ierr . ne . 0 ) exit string = string // trim ( line ) // '+' ! append output lines together enddo call unit_check ( 'process_readline' , string . eq . 'a+b+c+' , string ) call process_close ( fp , ierr ) ! Wrap up call unit_check_done ( 'process_readline' , msg = '' ) end subroutine test_process_readline !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_writeline_array () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines integer :: lun integer :: ios integer :: i character ( len = :), allocatable :: text (:) character ( len =* ), parameter :: lines ( * ) = [ character ( len = 10 ) :: 'one' , 'two' , 'three' , 'four' ] character ( len = 256 ) :: line call unit_check_start ( 'process_writeline_array' , msg = '' ) ! clear scratch file open ( newunit = lun , file = '_scratch_.txt' , iostat = ios ) close ( unit = lun , iostat = ios , status = 'delete' ) ! start shell call process_open_write ( 'bash||cmd' , fp , ierr ) ! open process to write to ! feed commands to shell that redirect output to _scratch_.txt file text = [ character ( len = 128 ) :: & \"echo one   >_scratch_.txt\" , & \"echo two   >>_scratch_.txt\" , & \"echo three >>_scratch_.txt\" , & \"echo four  >>_scratch_.txt\" ] call process_writeline ( text , fp , ierr ) ! multiple lines call unit_check ( 'process_writeline_array' , ierr . ge . 0 , 'wrote four lines, ierr=' , ierr ) call process_close ( fp , ierr ) ! check expected file open ( newunit = lun , file = '_scratch_.txt' ) do i = 1 , 4 read ( lun , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit call unit_check ( 'process_writeline_array' , line . eq . lines ( i ), 'got ' , line , 'expected' , line ) enddo close ( unit = lun , iostat = ios , status = 'delete' ) call unit_check ( 'process_writeline_array' , i . eq . 5 , 'number of lines' , i - 1 ) call unit_check_done ( 'process_writeline_array' , msg = '' ) end subroutine test_process_writeline_array !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_process_writeline_scalar () type ( streampointer ) :: fp ! C file pointer returned by process_open() integer :: ierr ! check status of calls to process module routines integer :: lun integer :: ios integer :: i character ( len =* ), parameter :: lines ( * ) = [ character ( len = 10 ) :: 'one' , 'two' , 'three' , 'four' ] character ( len = 256 ) :: line call unit_check_start ( 'process_writeline_scalar' , msg = '' ) ! clear scratch file open ( newunit = lun , file = '_scratch_.txt' , iostat = ios ) close ( unit = lun , iostat = ios , status = 'delete' ) ! start shell call process_open_write ( 'bash||cmd' , fp , ierr ) ! open process to write to (ie. start gnuplot(1) program) ! feed commands to shell that redirect output to _scratch_.txt file call process_writeline ( 'echo one    >_scratch_.txt' , fp , ierr ) call process_writeline ( 'echo two   >>_scratch_.txt' , fp , ierr ) call process_writeline ( 'echo three >>_scratch_.txt' , fp , ierr ) call process_writeline ( 'echo four  >>_scratch_.txt' , fp , ierr ) call process_close ( fp , ierr ) ! check expected file open ( newunit = lun , file = '_scratch_.txt' ) do i = 1 , size ( lines ) read ( lun , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit call unit_check ( 'process_writeline_scalar' , line . eq . lines ( i ), line ) enddo close ( unit = lun , iostat = ios , status = 'delete' ) call unit_check ( 'process_writeline_scalar' , i . eq . 5 , 'number of lines' , i ) call unit_check_done ( 'process_writeline_scalar' , msg = '' ) end subroutine test_process_writeline_scalar !=================================================================================================================================== end subroutine test_suite_M_process","tags":"","url":"sourcefile/test_suite_m_process.f90.html"}]}