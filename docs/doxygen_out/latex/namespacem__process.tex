\hypertarget{namespacem__process}{}\section{m\+\_\+process Module Reference}
\label{namespacem__process}\index{m\+\_\+process@{m\+\_\+process}}


\subsubsection*{N\+A\+ME}

M\+\_\+process(3fm) -\/ \mbox{[}M\+\_\+process\mbox{]} Fortran Module for calling process-\/related C functions from Fortran (L\+I\+C\+E\+N\+SE\+:PD)  


\subsection*{Data Types}
\begin{DoxyCompactItemize}
\item 
interface \mbox{\hyperlink{interfacem__process_1_1fflush}{fflush}}
\begin{DoxyCompactList}\small\item\em \subsubsection*{N\+A\+ME}

fflush(3fp) -\/ flush buffered file output \subsubsection*{S\+Y\+N\+O\+P\+S\+IS}\end{DoxyCompactList}\item 
interface \mbox{\hyperlink{interfacem__process_1_1process__writeline}{process\+\_\+writeline}}
\item 
type \mbox{\hyperlink{structm__process_1_1streampointer}{streampointer}}
\item 
interface \mbox{\hyperlink{interfacem__process_1_1system__fgets}{system\+\_\+fgets}}
\begin{DoxyCompactList}\small\item\em \subsubsection*{N\+A\+ME}

fgets(3fp) -\/ get character string from a file or stream by calling fgets(3c) \subsubsection*{S\+Y\+N\+O\+P\+S\+IS}\end{DoxyCompactList}\item 
interface \mbox{\hyperlink{interfacem__process_1_1system__fputs}{system\+\_\+fputs}}
\begin{DoxyCompactList}\small\item\em \subsubsection*{N\+A\+ME}

fputs(3fp) -\/ write a character string in a file or stream \subsubsection*{S\+Y\+N\+O\+P\+S\+IS}\end{DoxyCompactList}\item 
interface \mbox{\hyperlink{interfacem__process_1_1system__pclose}{system\+\_\+pclose}}
\item 
interface \mbox{\hyperlink{interfacem__process_1_1system__popen}{system\+\_\+popen}}
\end{DoxyCompactItemize}
\subsection*{Functions/\+Subroutines}
\begin{DoxyCompactItemize}
\item 
subroutine, public \mbox{\hyperlink{namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d}{process\+\_\+open\+\_\+read}} (cmd, fp, ierr)
\item 
subroutine, public \mbox{\hyperlink{namespacem__process_aa6ed1404ab3472f5068ed15a7a01defc}{process\+\_\+open\+\_\+write}} (cmd, fp, ierr)
\item 
subroutine, private \mbox{\hyperlink{namespacem__process_a3c0f543a9ceff2671041d73660f60a59}{process\+\_\+open}} (cmd, mode, fp, ierr)
\begin{DoxyCompactList}\small\item\em \subsubsection*{N\+A\+ME}

(L\+I\+C\+E\+N\+SE\+:PD) \subsubsection*{S\+Y\+N\+O\+P\+S\+IS}\end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacem__process_ab4c5cad3fb46686f0c9b71c3a634f6ae}{process\+\_\+close}} (fp, ierr)
\item 
subroutine, public \mbox{\hyperlink{namespacem__process_acbc72c5ed371430a471aa1f3010fbbda}{process\+\_\+readline}} (readfrom, fp, ierr)
\item 
character(len=\+:) function, allocatable, public \mbox{\hyperlink{namespacem__process_a7dd759a1344789477ae1e205d7fa9a51}{process\+\_\+readall}} (cmd, delim, ierr)
\begin{DoxyCompactList}\small\item\em \subsubsection*{N\+A\+ME}

process\+\_\+readall(3f) -\/ \mbox{[}M\+\_\+process\mbox{]} read all lines from process into single string (L\+I\+C\+E\+N\+SE\+:PD) \subsubsection*{S\+Y\+N\+O\+P\+S\+IS}\end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespacem__process_a72527c0ec0af26dcb14b8bfad6dcd482}{process\+\_\+writeline\+\_\+scalar}} (writefrom, fp, ierr, trm)
\item 
subroutine \mbox{\hyperlink{namespacem__process_a08887a918eba167ceacddf58ca084270}{process\+\_\+writeline\+\_\+array}} (writefrom, fp, ierr)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
logical, public \mbox{\hyperlink{namespacem__process_a0fabee8d01338d5523fbdea5c5f1e894}{process\+\_\+debug}} =.false.
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{N\+A\+ME}

M\+\_\+process(3fm) -\/ \mbox{[}M\+\_\+process\mbox{]} Fortran Module for calling process-\/related C functions from Fortran (L\+I\+C\+E\+N\+SE\+:PD) 

\subsubsection*{S\+Y\+N\+O\+P\+S\+IS}

\begin{DoxyVerb}use M_process, only : process_open_read, process_open_write, process_close
use M_process, only : process_readline, process_readall, process_writeline
use M_process, only : streampointer, process_debug
\end{DoxyVerb}


\subsubsection*{D\+E\+S\+C\+R\+I\+P\+T\+I\+ON}

Module M\+\_\+process(3f) lets Fortran code read/write lines from/to processes.

These Fortran procedures use the I\+S\+O\+\_\+\+C\+\_\+\+B\+I\+N\+D\+I\+NG interface to define Fortran-\/callable versions of the C procedures popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-\/oriented wrapper routines are then used to create a simple Fortran-\/callable interface.

Basically, you

o Open a process for either reading from or writing to using formatted sequential text records (eg. \char`\"{}lines\char`\"{}); much like with a regular file. o pass a C\+H\+A\+R\+A\+C\+T\+ER variable to/from the process that represents a record. o Use internal R\+E\+A\+Ds and internal W\+R\+I\+T\+Es or parsing routines to create or interpret the lines. o when done close the process much like closing a file.

The procedures defined are\+:

! open process to read from subroutine process\+\_\+open\+\_\+read(cmd,fp,ierr)

! open process to write to subroutine process\+\_\+open\+\_\+write(cmd,fp,ierr)

! read line from process subroutine process\+\_\+readline(string,fp,ierr) ! read all of process output into a string string function process\+\_\+readall(cmd,ierr) result (string)

! write lines to process subroutine \mbox{\hyperlink{interfacem__process_1_1process__writeline}{process\+\_\+writeline}}(string$\vert$string\+\_\+array,fp,ierr\mbox{[},trm=.t.$\vert$.f.\mbox{]})

! close process subroutine process\+\_\+close(fp,ierr)

where the variable types are

character(len=$\ast$) \+:\+: cmd type(streampointer) \+:\+: fp character(len=$\ast$) \+:\+: string integer \+:\+: ierr

\subsubsection*{O\+P\+T\+I\+O\+NS}

\begin{DoxyVerb}cmd      command passed to system to start process
fp       C file pointer returned by process_open_*()
string   data line to send or receive from process
ierr     error flag returned.

          o process_writeline(3f) : negative indicates an error
          o process_readline(3f)  : Non-zero indicates an error

maximum character value length is currently 4096
\end{DoxyVerb}


\subsubsection*{E\+X\+A\+M\+P\+L\+ES}

\begin{DoxyVerb}An example that places all the output of a command into a single
string variable (see process_readall(3) for an even simpler way to
do this) ...

  program read_ex
   use M_process ,only: process_open_read, process_readline
   use M_process ,only: streampointer, process_close
   implicit none
   ! C file pointer returned by process_open()
   type(streampointer) :: fp
   ! check status of calls to process module routines
   integer :: ierr
   ! hold results, assuming sufficient memory is available
   character(len=:),allocatable :: string
   ! long enough to hold any expected line
   character(len=4096) :: line

      string=''

      !###! open process to read from
      call process_open_read('ls',fp,ierr)

      !###! read output of process till end
      do
         call process_readline(line,fp,ierr)
         if(ierr.ne.0)exit
         !###! append output lines together
         string=string//trim(line)//' '
         write(*,*)'['//string//']'
      enddo

      write(*,*)trim(string)

      !###! Wrap up
      call process_close(fp,ierr)

  end program read_ex

When calling a line-mode program from another program the most natural
way is to open a process and write to it.

Following is an example program that calls the M_process module to
start a plotting program called gnuplot(1) and give it enough commands
to generate a plot. It then lets you interactively interact with the
gnuplot(1) program or continue on in the program.

 program gnuplotExample
  use M_process ,only: process_open_write, process_writeline
  use M_process ,only: streampointer, process_close
  implicit none
  !
  ! Example of Fortran writing GNUPLOT command and data file.
  !
  character(len=4096) :: line                     !*! line of data to write (assumed long enough to hold any command line)
  type(streampointer) :: fp                       !*! C file pointer returned by process_open()
  integer :: ierr                                 !*! check status of calls to process module routines
  integer :: i                                    !*! DO loop counter
  integer,parameter   :: n=50                     !*! number of points to put into curve to be plotted
  real                :: x(n),y(n)                !*! arrays to fill with curve data to be plotted
  integer             :: ios

  !*! Define sample X,Y array.
  do i=1,n                                        !*! set X() values as whole numbers 1 to N
     x(i)=i
     !*!
     y(i)=(x(i)+0.5)**2
  enddo
                                                  !*! Write the GnuPlot commands
  call process_open_write('gnuplot',fp,ierr)      !*! open process to write to (ie. start gnuplot(1) program)
  call process_writeline('$SET1 <<EOD',fp,ierr)   !*! create in-line dataset $SET1
  do i=1,n
     write(line,'(2(f10.3,1x))')x(i),y(i)         !*! Write the X,Y array as coordinates to be plotted.
     call process_writeline(line,fp,ierr)
  enddo

  call process_writeline([character(len=128) ::                        &
  &'EOD                                                             ', &
  &'set title " Example of GNUPlot data and command file generation"', &
  &'set nokey'                                                       , &
  &'plot $SET1 with lines'                                           , &
  &''],fp,ierr)

  write(*,'(a)')'enter gnuplot commands or "." to exit'   !*! Additional gnuplot commands; in this case interactively entered
  do
     write(*,'(a)',advance='no')'gnu>>'
     read(*,'(a)',iostat=ios)line
     if(line.eq.'.')exit
     call process_writeline(trim(line),fp,ierr)
  enddo
                                                          !*! Wrap up
  call process_close(fp,ierr)
  write(*,*)'CLOSED THE PROCESS. RETURNING TO PROGRAM'
  end program gnuplotExample
\end{DoxyVerb}


This program starts a bash shell that, among other things, calls sqlite3 and gnuplot. In this case the text is fixed to keep the example simple. More typically the text would be conditionally selected or generated by the program. \begin{DoxyVerb}program demo_M_process
use M_process ,only : process_open_write, process_writeline
use M_process ,only : streampointer, process_close
implicit none
type(streampointer) :: fp                     ! C file pointer returned by process_open()
integer :: ierr                               ! check status of calls to process module routines
character(len=:),allocatable :: text(:)

!!call process_open_write('cat',fp,ierr)       ! open process to write to (ie. start gnuplot(1) program)
call process_open_write('bash',fp,ierr)       ! open process to write to (ie. start gnuplot(1) program)

text=[character(len=128) :: &
"rm -f sqlite1.db", &
"sqlite3 sqlite1.db <<\EOF", &
"-- *****************************************************************************", &
"CREATE TABLE IF NOT EXISTS animals(", &
"   name        TEXT           NOT NULL   PRIMARY KEY ,", &
"   hair        INT            NOT NULL   ,", &
"   mobility    INT            NOT NULL   ,", &
"   vision      INT            NOT NULL   );", &
"-- *****************************************************************************", &
"INSERT INTO animals ( name, hair, mobility, vision ) VALUES ( 'kittens'  , 4, 5, 1 ) ;", &
"INSERT INTO animals ( name, hair, mobility, vision ) VALUES ( 'mice'     , 6, 7, 2 ) ;", &
"INSERT INTO animals ( name, hair, mobility, vision ) VALUES ( 'rats'     , 2, 3, 3 ) ;", &
"-- *****************************************************************************", &
".quit", &
"EOF", &
"################################################################################", &
"sqlite3 -header -column sqlite1.db  'select * from animals'", &
"sqlite3 sqlite1.db  'select name, hair, mobility, vision from animals'", &
"################################################################################", &
"gnuplot --persist <<\EOF                                                              ", &
"########################################                                              ", &
"#set terminal gif                                                                     ", &
"#set output 'M_process.3.gif'                                                         ", &
"########################################                                              ", &
"#set terminal png                                                                     ", &
"#set output 'bar.png'                                                                 ", &
"########################################                                              ", &
"#set terminal pdf enhanced                                                            ", &
"#set output 'bar.pdf'                                                                 ", &
"########################################                                              ", &
"#set style data lines                                                                 ", &
"########################################                                              ", &
"set datafile separator ""|""                                                          ", &
"set style data histogram                                                              ", &
"set style histogram cluster gap 1                                                     ", &
"set style fill solid border rgb ""black""                                             ", &
"set auto x                                                                            ", &
"set yrange [0:*]                                                                      ", &
"plot ""< sqlite3 sqlite1.db  'select name, hair, mobility, vision  from animals'"" \  ", &
"      using 2:xtic(1) title ""hair"",  \                                              ", &
"   '' using 4:xtic(1) title ""vision"", \                                             ", &
"   '' using 3:xtic(1) title ""mobility""                                              ", &
"quit                                                                                  ", &
"EOF                                                                                   ", &
" "]

   !!write(*,'(a)')text
   call process_writeline(text,fp,ierr)
   call process_close(fp,ierr)
   write(*,'(a)')'CLOSED THE PROCESS. RETURNING TO PROGRAM'

end program demo_M_process
\end{DoxyVerb}


This example shows a routine to read the output of one command and other routine to write data to. \begin{DoxyVerb}program test
   call readit('ls -l')
   call writeit('cat -n')
contains
!-------------------------------------------------------------------------------
subroutine readit(cmd)
   use M_process ,ONLY: process_open_read, process_readline, streampointer, process_close
   type(streampointer) :: fp    ! C file pointer returned by process_open()
   character(len=*)    :: cmd   ! command line executed to start process
   character(len=4096) :: line  ! line of data to read (assumed long enough to hold any input line)
   integer ierr
   call process_open_read(cmd,fp,ierr)   ! open process to read from
   write(*,*)'READTEST: process is opened with status ',ierr
   ierr=0
   do while(ierr .eq. 0)
      call process_readline(line,fp,ierr)  ! read a line from the process
      if(ierr.ne.0)then
         write(*,*)'READTEST: ierr is ',ierr
         exit
      endif
      write(*,*)'READTEST: line:'//trim(line)
   enddo
   call process_close(fp,ierr)
   write(*,*)'READTEST: process closed with status ',ierr
end subroutine readit
!-------------------------------------------------------------------------------
subroutine writeit(cmd)
use M_process ,ONLY: process_open_write, process_writeline, streampointer, process_close
type(streampointer) :: fp       ! C file pointer returned by process_open()
character(len=*) :: cmd         ! command line executed to start process
   character(len=4096) :: line  ! line of data to write (assumed long enough to hold any output line)
   integer ierr
   integer i
   call process_open_write(cmd,fp,ierr)   ! open process to write to
   write(*,*)'WRITETEST: process is opened'
   ierr=0
   do i=1,10
      write(line,'("WRITETEST: line ",i0)')i
      call process_writeline(line,fp,ierr)
      if(ierr.lt.0)then
         write(*,*)'WRITETEST: process write error ',ierr
         exit
      endif
   enddo
   call process_close(fp,ierr)
   write(*,*)'WRITETEST: process closed with status ',ierr
end subroutine writeit
end program test
\end{DoxyVerb}


\subsubsection*{S\+EE A\+L\+SO}

o P\+I\+P\+ES\+: pipe(3c), popen(3c), pclose(3c), fflush(3c) o N\+A\+M\+ED P\+I\+P\+ES\+: mkfifo(3c), mknod(3c) o S\+U\+B\+P\+R\+O\+C\+E\+S\+S\+ES\+: fork(3c) o O\+T\+H\+ER\+: fflush(3c) \subsubsection*{A\+U\+T\+H\+OR}

John S. Urban \subsubsection*{L\+I\+C\+E\+N\+SE}

Public Domain

D\+E\+S\+C\+R\+I\+P\+T\+I\+ON\+: record-\/oriented Fortran I/O interface to C procedures popen/pclose and fgets/fputs and process-\/related procedures \subsubsection*{V\+E\+R\+S\+I\+ON\+: 2.\+0.\+0, 20161105}

A\+U\+T\+H\+OR\+: John S. Urban 

\subsection{Function/\+Subroutine Documentation}
\mbox{\Hypertarget{namespacem__process_ab4c5cad3fb46686f0c9b71c3a634f6ae}\label{namespacem__process_ab4c5cad3fb46686f0c9b71c3a634f6ae}} 
\index{m\+\_\+process@{m\+\_\+process}!process\+\_\+close@{process\+\_\+close}}
\index{process\+\_\+close@{process\+\_\+close}!m\+\_\+process@{m\+\_\+process}}
\subsubsection{\texorpdfstring{process\+\_\+close()}{process\_close()}}
{\footnotesize\ttfamily subroutine, public m\+\_\+process\+::process\+\_\+close (\begin{DoxyParamCaption}\item[{type(\mbox{\hyperlink{structm__process_1_1streampointer}{streampointer}})}]{fp,  }\item[{integer, intent(out)}]{ierr }\end{DoxyParamCaption})}



References process\+\_\+debug.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{namespacem__process_ab4c5cad3fb46686f0c9b71c3a634f6ae_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacem__process_a3c0f543a9ceff2671041d73660f60a59}\label{namespacem__process_a3c0f543a9ceff2671041d73660f60a59}} 
\index{m\+\_\+process@{m\+\_\+process}!process\+\_\+open@{process\+\_\+open}}
\index{process\+\_\+open@{process\+\_\+open}!m\+\_\+process@{m\+\_\+process}}
\subsubsection{\texorpdfstring{process\+\_\+open()}{process\_open()}}
{\footnotesize\ttfamily subroutine, private m\+\_\+process\+::process\+\_\+open (\begin{DoxyParamCaption}\item[{character(len=$\ast$), intent(in)}]{cmd,  }\item[{character(len=$\ast$), intent(in)}]{mode,  }\item[{type(\mbox{\hyperlink{structm__process_1_1streampointer}{streampointer}}), intent(out)}]{fp,  }\item[{integer, intent(out)}]{ierr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



\subsubsection*{N\+A\+ME}

(L\+I\+C\+E\+N\+SE\+:PD) \subsubsection*{S\+Y\+N\+O\+P\+S\+IS}

\subsubsection*{D\+E\+S\+C\+R\+I\+P\+T\+I\+ON}

\subsubsection*{E\+X\+A\+M\+P\+LE}

\subsubsection*{A\+U\+T\+H\+OR}

John S. Urban \subsubsection*{L\+I\+C\+E\+N\+SE}

Public Domain 

References process\+\_\+debug.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacem__process_a3c0f543a9ceff2671041d73660f60a59_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d}\label{namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d}} 
\index{m\+\_\+process@{m\+\_\+process}!process\+\_\+open\+\_\+read@{process\+\_\+open\+\_\+read}}
\index{process\+\_\+open\+\_\+read@{process\+\_\+open\+\_\+read}!m\+\_\+process@{m\+\_\+process}}
\subsubsection{\texorpdfstring{process\+\_\+open\+\_\+read()}{process\_open\_read()}}
{\footnotesize\ttfamily subroutine, public m\+\_\+process\+::process\+\_\+open\+\_\+read (\begin{DoxyParamCaption}\item[{character(len=$\ast$), intent(in)}]{cmd,  }\item[{type(\mbox{\hyperlink{structm__process_1_1streampointer}{streampointer}}), intent(out)}]{fp,  }\item[{integer, intent(out)}]{ierr }\end{DoxyParamCaption})}



References process\+\_\+open().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacem__process_aa6ed1404ab3472f5068ed15a7a01defc}\label{namespacem__process_aa6ed1404ab3472f5068ed15a7a01defc}} 
\index{m\+\_\+process@{m\+\_\+process}!process\+\_\+open\+\_\+write@{process\+\_\+open\+\_\+write}}
\index{process\+\_\+open\+\_\+write@{process\+\_\+open\+\_\+write}!m\+\_\+process@{m\+\_\+process}}
\subsubsection{\texorpdfstring{process\+\_\+open\+\_\+write()}{process\_open\_write()}}
{\footnotesize\ttfamily subroutine, public m\+\_\+process\+::process\+\_\+open\+\_\+write (\begin{DoxyParamCaption}\item[{character(len=$\ast$), intent(in)}]{cmd,  }\item[{type(\mbox{\hyperlink{structm__process_1_1streampointer}{streampointer}}), intent(out)}]{fp,  }\item[{integer, intent(out)}]{ierr }\end{DoxyParamCaption})}



References process\+\_\+open().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacem__process_aa6ed1404ab3472f5068ed15a7a01defc_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacem__process_a7dd759a1344789477ae1e205d7fa9a51}\label{namespacem__process_a7dd759a1344789477ae1e205d7fa9a51}} 
\index{m\+\_\+process@{m\+\_\+process}!process\+\_\+readall@{process\+\_\+readall}}
\index{process\+\_\+readall@{process\+\_\+readall}!m\+\_\+process@{m\+\_\+process}}
\subsubsection{\texorpdfstring{process\+\_\+readall()}{process\_readall()}}
{\footnotesize\ttfamily character(len=\+:) function, allocatable, public m\+\_\+process\+::process\+\_\+readall (\begin{DoxyParamCaption}\item[{character(len=$\ast$), intent(in)}]{cmd,  }\item[{character(len=$\ast$), intent(in), optional}]{delim,  }\item[{integer, intent(out), optional}]{ierr }\end{DoxyParamCaption})}



\subsubsection*{N\+A\+ME}

process\+\_\+readall(3f) -\/ \mbox{[}M\+\_\+process\mbox{]} read all lines from process into single string (L\+I\+C\+E\+N\+SE\+:PD) \subsubsection*{S\+Y\+N\+O\+P\+S\+IS}

syntax\+:

function process\+\_\+readall(cmd,delim,ierr) result(string)

character(len=$\ast$),intent(in) \+:\+: cmd character(len=$\ast$),intent(in),optional \+:\+: delim integer,intent(out),optional \+:\+: ierr character(len=\+:),allocatable \+:\+: string \subsubsection*{O\+P\+T\+I\+O\+NS}

cmd command to pass to system delim delimiter to place between output lines when they are concatenated. Defaults to a space ierr check status of call. \subsubsection*{R\+E\+S\+U\+L\+TS}

process\+\_\+readall Assuming sufficient memory is available all the output of the system command are concatenated into a string with spaces added between the output lines of the command. \subsubsection*{E\+X\+A\+M\+P\+LE}

Read all output of a command to a single string \begin{DoxyVerb} program test_process_readall
 use M_process ,only: process_readall
 implicit none
 integer :: ierr
 character(len=:),allocatable :: string
    string=process_readall('ls',ierr=ierr)
    write(*,*)ierr,string
 end program test_process_readall
\end{DoxyVerb}


Read all output of a command to an array using split(3f) \begin{DoxyVerb} program demo_process_readall
 use M_process ,only: process_readall
 use M_strings ,only: split
 implicit none
 integer                      :: ierr
 integer                      :: i
 character(len=:),allocatable :: string
 character(len=:),allocatable :: array(:)
    string=process_readall('ls',delim=NEW_LINE("A"),ierr=ierr)
    call split(string,array,delimiters=NEW_LINE("A"))
    do i=1,size(array)
       write(*,'(i0,t10,"[",a,"]")')i,trim(array(i))
    enddo
 end program demo_process_readall
\end{DoxyVerb}


Results\+: \begin{DoxyVerb}> 1     [Articles]
> 2     [LIBRARY]
> 3     [PC]
> 4     [SHIP]
> 5     [SPEC]
> 6     [crib.dat]
> 7     [doc]
> 8     [html]
> 9     [index.html]
> 10    [plan.txt]
> 11    [questions]
> 12    [scripts]
> 13    [tmp]
\end{DoxyVerb}


\subsubsection*{S\+EE A\+L\+SO}

M\+\_\+process(3fm) \subsubsection*{A\+U\+T\+H\+OR}

John S. Urban \subsubsection*{L\+I\+C\+E\+N\+SE}

Public Domain 

References process\+\_\+close(), process\+\_\+open\+\_\+read(), and process\+\_\+readline().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacem__process_a7dd759a1344789477ae1e205d7fa9a51_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacem__process_acbc72c5ed371430a471aa1f3010fbbda}\label{namespacem__process_acbc72c5ed371430a471aa1f3010fbbda}} 
\index{m\+\_\+process@{m\+\_\+process}!process\+\_\+readline@{process\+\_\+readline}}
\index{process\+\_\+readline@{process\+\_\+readline}!m\+\_\+process@{m\+\_\+process}}
\subsubsection{\texorpdfstring{process\+\_\+readline()}{process\_readline()}}
{\footnotesize\ttfamily subroutine, public m\+\_\+process\+::process\+\_\+readline (\begin{DoxyParamCaption}\item[{character(len=$\ast$), intent(out)}]{readfrom,  }\item[{type(\mbox{\hyperlink{structm__process_1_1streampointer}{streampointer}}), intent(in)}]{fp,  }\item[{integer, intent(out)}]{ierr }\end{DoxyParamCaption})}



References process\+\_\+debug.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{namespacem__process_acbc72c5ed371430a471aa1f3010fbbda_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacem__process_a08887a918eba167ceacddf58ca084270}\label{namespacem__process_a08887a918eba167ceacddf58ca084270}} 
\index{m\+\_\+process@{m\+\_\+process}!process\+\_\+writeline\+\_\+array@{process\+\_\+writeline\+\_\+array}}
\index{process\+\_\+writeline\+\_\+array@{process\+\_\+writeline\+\_\+array}!m\+\_\+process@{m\+\_\+process}}
\subsubsection{\texorpdfstring{process\+\_\+writeline\+\_\+array()}{process\_writeline\_array()}}
{\footnotesize\ttfamily subroutine m\+\_\+process\+::process\+\_\+writeline\+\_\+array (\begin{DoxyParamCaption}\item[{character(len=$\ast$), dimension(\+:), intent(in)}]{writefrom,  }\item[{type(\mbox{\hyperlink{structm__process_1_1streampointer}{streampointer}}), intent(in)}]{fp,  }\item[{integer, intent(out)}]{ierr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



References process\+\_\+debug, and process\+\_\+writeline\+\_\+scalar().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{namespacem__process_a08887a918eba167ceacddf58ca084270_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacem__process_a72527c0ec0af26dcb14b8bfad6dcd482}\label{namespacem__process_a72527c0ec0af26dcb14b8bfad6dcd482}} 
\index{m\+\_\+process@{m\+\_\+process}!process\+\_\+writeline\+\_\+scalar@{process\+\_\+writeline\+\_\+scalar}}
\index{process\+\_\+writeline\+\_\+scalar@{process\+\_\+writeline\+\_\+scalar}!m\+\_\+process@{m\+\_\+process}}
\subsubsection{\texorpdfstring{process\+\_\+writeline\+\_\+scalar()}{process\_writeline\_scalar()}}
{\footnotesize\ttfamily subroutine m\+\_\+process\+::process\+\_\+writeline\+\_\+scalar (\begin{DoxyParamCaption}\item[{character(len=$\ast$), intent(in)}]{writefrom,  }\item[{type(\mbox{\hyperlink{structm__process_1_1streampointer}{streampointer}}), intent(in)}]{fp,  }\item[{integer, intent(out)}]{ierr,  }\item[{logical, intent(in), optional}]{trm }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



References process\+\_\+debug.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{namespacem__process_a72527c0ec0af26dcb14b8bfad6dcd482_icgraph}
\end{center}
\end{figure}


\subsection{Variable Documentation}
\mbox{\Hypertarget{namespacem__process_a0fabee8d01338d5523fbdea5c5f1e894}\label{namespacem__process_a0fabee8d01338d5523fbdea5c5f1e894}} 
\index{m\+\_\+process@{m\+\_\+process}!process\+\_\+debug@{process\+\_\+debug}}
\index{process\+\_\+debug@{process\+\_\+debug}!m\+\_\+process@{m\+\_\+process}}
\subsubsection{\texorpdfstring{process\+\_\+debug}{process\_debug}}
{\footnotesize\ttfamily logical, public m\+\_\+process\+::process\+\_\+debug =.false.}

