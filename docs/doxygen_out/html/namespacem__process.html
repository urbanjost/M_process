<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M_process: m_process Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">M_process
   </div>
   <div id="projectbrief">M_process module (Fortran)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">m_process Module Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__process_1_1fflush.html">fflush</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__process_1_1process__writeline.html">process_writeline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structm__process_1_1streampointer.html">streampointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__process_1_1system__fgets.html">system_fgets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__process_1_1system__fputs.html">system_fputs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__process_1_1system__pclose.html">system_pclose</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__process_1_1system__popen.html">system_popen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:aaaf4d1926258a4cec7da7fc61c38c79d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__process.html#aaaf4d1926258a4cec7da7fc61c38c79d">process_open_read</a> (cmd, fp, ierr)</td></tr>
<tr class="separator:aaaf4d1926258a4cec7da7fc61c38c79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ed1404ab3472f5068ed15a7a01defc"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__process.html#aa6ed1404ab3472f5068ed15a7a01defc">process_open_write</a> (cmd, fp, ierr)</td></tr>
<tr class="separator:aa6ed1404ab3472f5068ed15a7a01defc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0f543a9ceff2671041d73660f60a59"><td class="memItemLeft" align="right" valign="top">subroutine, private&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__process.html#a3c0f543a9ceff2671041d73660f60a59">process_open</a> (cmd, mode, fp, ierr)</td></tr>
<tr class="separator:a3c0f543a9ceff2671041d73660f60a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c5cad3fb46686f0c9b71c3a634f6ae"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__process.html#ab4c5cad3fb46686f0c9b71c3a634f6ae">process_close</a> (fp, ierr)</td></tr>
<tr class="separator:ab4c5cad3fb46686f0c9b71c3a634f6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc72c5ed371430a471aa1f3010fbbda"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__process.html#acbc72c5ed371430a471aa1f3010fbbda">process_readline</a> (readfrom, fp, ierr)</td></tr>
<tr class="separator:acbc72c5ed371430a471aa1f3010fbbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd759a1344789477ae1e205d7fa9a51"><td class="memItemLeft" align="right" valign="top">character(len=:) function, allocatable, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__process.html#a7dd759a1344789477ae1e205d7fa9a51">process_readall</a> (cmd, delim, ierr)</td></tr>
<tr class="separator:a7dd759a1344789477ae1e205d7fa9a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72527c0ec0af26dcb14b8bfad6dcd482"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__process.html#a72527c0ec0af26dcb14b8bfad6dcd482">process_writeline_scalar</a> (writefrom, fp, ierr, trm)</td></tr>
<tr class="separator:a72527c0ec0af26dcb14b8bfad6dcd482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08887a918eba167ceacddf58ca084270"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__process.html#a08887a918eba167ceacddf58ca084270">process_writeline_array</a> (writefrom, fp, ierr)</td></tr>
<tr class="separator:a08887a918eba167ceacddf58ca084270"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0fabee8d01338d5523fbdea5c5f1e894"><td class="memItemLeft" align="right" valign="top">logical, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__process.html#a0fabee8d01338d5523fbdea5c5f1e894">process_debug</a> =.false.</td></tr>
<tr class="separator:a0fabee8d01338d5523fbdea5c5f1e894"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h2><a class="anchor" id="autotoc_md0"></a>
NAME</h2>
<p>M_process(3fm) - [M_process::INTRO] Fortran Module for calling process-related C functions from Fortran (LICENSE:PD)</p>
<h2><a class="anchor" id="autotoc_md1"></a>
SYNOPSIS</h2>
<pre class="fragment"> use M_process, only : process_open_read, process_open_write, process_close

 use M_process, only : process_readline, process_readall, process_writeline

 use M_process, only : streampointer, process_debug
</pre><h2><a class="anchor" id="autotoc_md2"></a>
DESCRIPTION</h2>
<p>Module M_process(3f) lets Fortran code read/write lines from/to processes.</p>
<p>These Fortran procedures use the ISO_C_BINDING interface to define Fortran-callable versions of the C procedures popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines are then used to create a simple Fortran-callable interface.</p>
<p>A POSIX C interface is generally available but may require using a Linux subwindow or an application such as CygWin on MSWindows platforms.</p>
<p>Basically, you</p>
<p>o Open a process for either reading from or writing to using formatted sequential text records (eg. "lines"); much like with a regular file. o pass a CHARACTER variable to/from the process that represents a record. o Use internal READs and internal WRITEs or parsing routines to create or interpret the lines. o when done close the process much like closing a file.</p>
<p>The procedures defined are:</p>
<p>! open process to read from subroutine process_open_read(cmd,fp,ierr)</p>
<p>! open process to write to subroutine process_open_write(cmd,fp,ierr)</p>
<p>! read line from process subroutine process_readline(string,fp,ierr) ! read all of process output into a string string function process_readall(cmd,ierr) result (string)</p>
<p>! write lines to process subroutine <a class="el" href="interfacem__process_1_1process__writeline.html">process_writeline</a> &amp; &amp; (string|string_array,fp,ierr[,trm=.t.|.f.])</p>
<p>! close process subroutine process_close(fp,ierr)</p>
<p>where the variable types are</p>
<p>character(len=*) :: cmd type(streampointer) :: fp character(len=*) :: string integer :: ierr</p>
<h2><a class="anchor" id="autotoc_md3"></a>
OPTIONS</h2>
<pre class="fragment">cmd      command passed to system to start process
fp       C file pointer returned by process_open_*()
string   data line to send or receive from process
ierr     error flag returned.

          o process_writeline(3f) : negative indicates an error
          o process_readline(3f)  : Non-zero indicates an error

maximum character value length is currently 4096
</pre><h2><a class="anchor" id="autotoc_md4"></a>
EXAMPLES</h2>
<p>An example that places all the output of a command into a single string variable (see process_readall(3) for an even simpler way to do this) ...</p>
<p>program read_ex use M_process ,only: process_open_read, process_readline use M_process ,only: streampointer, process_close implicit none ! C file pointer returned by <a class="el" href="namespacem__process.html#a3c0f543a9ceff2671041d73660f60a59">process_open()</a> type(streampointer) :: fp ! check status of calls to process module routines integer :: ierr ! hold results, assuming sufficient memory is available character(len=:),allocatable :: string ! long enough to hold any expected line character(len=4096) :: line string='' !###! open process to read from call process_open_read('ls',fp,ierr) !###! read output of process till end do call process_readline(line,fp,ierr) if(ierr.ne.0)exit !###! append output lines together string=string//trim(line)//' ' write(*,*)'['//string//']' enddo write(*,*)trim(string) !###! Wrap up call process_close(fp,ierr) end program read_ex</p>
<p>When calling a line-mode program from another program the most natural way is to open a process and write to it.</p>
<p>Following is an example program that calls the M_process module to start a plotting program called gnuplot(1) and give it enough commands to generate a plot. It then lets you interactively interact with the gnuplot(1) program or continue on in the program.</p>
<p>program gnuplotExample use M_process ,only: process_open_write, <a class="el" href="interfacem__process_1_1process__writeline.html">process_writeline</a> use M_process ,only: streampointer, process_close implicit none ! ! Example of Fortran writing GNUPLOT command and data file. ! !*! line of data to write !*! (assumed long enough to hold any command line) character(len=4096) :: line !*! C file pointer returned by <a class="el" href="namespacem__process.html#a3c0f543a9ceff2671041d73660f60a59">process_open()</a> type(streampointer) :: fp !*! check status of calls to process module routines integer :: ierr !*! DO loop counter integer :: i !*! number of points to put into curve to be plotted integer,parameter :: n=50 !*! arrays to fill with curve data to be plotted real :: x(n),y(n) integer :: ios !*! Define sample X,Y array. do i=1,n !*! set X() values as whole numbers 1 to N x(i)=i !*! y(i)=(x(i)+0.5)**2 enddo !*! Write the GnuPlot commands !*! open process to write to (ie. start gnuplot(1) program) call process_open_write('gnuplot',fp,ierr) !*! create in-line dataset $SET1 call <a class="el" href="interfacem__process_1_1process__writeline.html">process_writeline</a>('$SET1 &lt;&lt;EOD',fp,ierr) do i=1,n !*! Write the X,Y array as coordinates to be plotted. write(line,'(2(f10.3,1x))')x(i),y(i) call process_writeline(line,fp,ierr) enddo</p>
<p>call <a class="el" href="interfacem__process_1_1process__writeline.html">process_writeline</a>([character(len=128) :: &amp; &amp;'EOD ', &amp; &amp;'set title " Example of GNUPlot data and command file generation"', &amp; &amp;'set nokey' , &amp; &amp;'plot $SET1 with lines' , &amp; &amp;''],fp,ierr)</p>
<p>!*! Additional gnuplot commands; in this case interactively entered write(*,'(a)')'enter gnuplot commands or "." to exit' do write(*,'(a)',advance='no')'gnu&gt;&gt;' read(*,'(a)',iostat=ios)line if(line.eq.'.')exit call process_writeline(trim(line),fp,ierr) enddo !*! Wrap up call process_close(fp,ierr) write(*,*)'CLOSED THE PROCESS. RETURNING TO PROGRAM' end program gnuplotExample</p>
<p>This program starts a bash shell that, among other things, calls sqlite3 and gnuplot. In this case the text is fixed to keep the example simple. More typically the text would be conditionally selected or generated by the program.</p>
<p>program demo_M_process use M_process ,only : process_open_write, <a class="el" href="interfacem__process_1_1process__writeline.html">process_writeline</a> use M_process ,only : streampointer, process_close implicit none ! C file pointer returned by <a class="el" href="namespacem__process.html#a3c0f543a9ceff2671041d73660f60a59">process_open()</a> type(streampointer) :: fp ! check status of calls to process module routines integer :: ierr character(len=:),allocatable :: text(:)</p>
<p>! open process to write to (ie. start gnuplot(1) program) !!call process_open_write('cat',fp,ierr) ! open process to write to (ie. start gnuplot(1) program) call process_open_write('bash',fp,ierr)</p>
<p>text=[character(len=128) :: &amp; "rm -f sqlite1.db", &amp; "sqlite3 sqlite1.db &lt;&lt;\EOF", &amp; "-- ***********************************************",&amp; "CREATE TABLE IF NOT EXISTS animals(               ",&amp; "   name        TEXT   NOT NULL   PRIMARY KEY ,    ",&amp; "   hair        INT    NOT NULL   ,                ",&amp; "   mobility    INT    NOT NULL   ,                ",&amp; "   vision      INT    NOT NULL   );               ",&amp; "-- ***********************************************",&amp; "INSERT INTO animals(&amp;
     &amp;name,hair,mobility,vision) VALUES('kittens',4,5,1);",&amp; "INSERT INTO animals(&amp;
     &amp;name,hair,mobility,vision) VALUES('mice'   ,6,7,2);",&amp; "INSERT INTO animals(&amp;
     &amp;name,hair,mobility,vision) VALUES('rats'   ,2,3,3);",&amp; "-- ***********************************************",&amp; ".quit", &amp; "EOF", &amp; "##################################################",&amp; "sqlite3 -header -column sqlite1.db  'select * from animals'",&amp; "sqlite3 sqlite1.db  &amp;
     &amp;'select name, hair, mobility, vision from animals'",&amp; "##################################################",&amp; "gnuplot --persist &lt;&lt;\EOF                          ",&amp; "########################################          ",&amp; "#set terminal gif                                 ",&amp; "#set output 'M_process.3.gif'                     ",&amp; "########################################          ",&amp; "#set terminal png                                 ",&amp; "#set output 'bar.png'                             ",&amp; "########################################          ",&amp; "#set terminal pdf enhanced                        ",&amp; "#set output 'bar.pdf'                             ",&amp; "########################################          ",&amp; "#set style data lines                             ",&amp; "########################################          ",&amp; "set datafile separator ""|""                      ",&amp; "set style data histogram                          ",&amp; "set style histogram cluster gap 1                 ",&amp; "set style fill solid border rgb ""black""         ",&amp; "set auto x                                        ",&amp; "set yrange [0:*]                                  ",&amp; "plot ""&lt; sqlite3 sqlite1.db  &amp;
     &amp;'select name, hair, mobility, vision  from animals'"" \  ", &amp; "      using 2:xtic(1) title ""hair"",  \          ",&amp; "   '' using 4:xtic(1) title ""vision"", \         ",&amp; "   '' using 3:xtic(1) title ""mobility""          ",&amp; "quit                                              ",&amp; "EOF                                               ",&amp; " "]</p>
<p>!!write(*,'(a)')text call process_writeline(text,fp,ierr) call process_close(fp,ierr) write(*,'(a)')'CLOSED THE PROCESS. RETURNING TO PROGRAM'</p>
<p>end program demo_M_process</p>
<p>This example shows a routine to read the output of one command and then call another command to write that output to. </p><pre class="fragment"> program test
 implicit none
   call readit('ls -l')
   call writeit('cat -n')
 contains

 subroutine readit(cmd)
 use M_process ,ONLY: process_open_read, process_readline
 use M_process ,ONLY: streampointer, process_close
 ! C file pointer returned by process_open()
 type(streampointer) :: fp
 ! command line executed to start process
 character(len=*)    :: cmd
 ! line of data to read (assumed long enough to hold any input line)
 character(len=4096) :: line
 integer ierr
   ! open process to read from
   call process_open_read(cmd,fp,ierr)
   write(*,*)'READTEST: process is opened with status ',ierr
   ierr=0
   do while(ierr .eq. 0)
     ! read a line from the process
     call process_readline(line,fp,ierr)
     if(ierr.ne.0)then
       write(*,*)'READTEST: ierr is ',ierr
       exit
     endif
     write(*,*)'READTEST: line:'//trim(line)
   enddo
   call process_close(fp,ierr)
   write(*,*)'READTEST: process closed with status ',ierr
 end subroutine readit
 !---------------------------------------------------------------------
 subroutine writeit(cmd)
 use M_process, only: process_open_write, process_writeline
 use M_process, only: streampointer, process_close
 ! C file pointer returned by process_open()
 type(streampointer) :: fp
 ! command line executed to start process
 character(len=*)    :: cmd
 ! line of data to write (assumed long enough to hold any output line)
 character(len=4096) :: line
 integer             :: ierr
 integer             :: i
   ! open process to write to
   call process_open_write(cmd,fp,ierr)
   write(*,*)'WRITETEST: process is opened'
   ierr=0
   do i=1,10
     write(line,'("WRITETEST: line ",i0)')i
     call process_writeline(line,fp,ierr)
     if(ierr.lt.0)then
       write(*,*)'WRITETEST: process write error ',ierr
       exit
     endif
   enddo
   call process_close(fp,ierr)
   write(*,*)'WRITETEST: process closed with status ',ierr
 end subroutine writeit
 end program test
</pre><h2><a class="anchor" id="autotoc_md5"></a>
SEE ALSO</h2>
<p>o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) o NAMED PIPES: mkfifo(3c), mknod(3c) o SUBPROCESSES: fork(3c) o OTHER: fflush(3c) </p>
<h2><a class="anchor" id="autotoc_md6"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md7"></a>
LICENSE</h2>
<p>Public Domain</p>
<p>DESCRIPTION: record-oriented Fortran I/O interface to C popen,pclose,fgets,fputs </p>
<h2><a class="anchor" id="autotoc_md8"></a>
VERSION:     2.0.0, 20161105</h2>
<p>AUTHOR: John S. Urban </p>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="ab4c5cad3fb46686f0c9b71c3a634f6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c5cad3fb46686f0c9b71c3a634f6ae">&#9670;&nbsp;</a></span>process_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public m_process::process_close </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structm__process_1_1streampointer.html">streampointer</a>)&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md44"></a>
NAME</h2>
<p>process_close(3fm) - [M_process] close a process being written to or read from (LICENSE:PD)</p>
<h2><a class="anchor" id="autotoc_md45"></a>
SYNOPSIS</h2>
<pre class="fragment"> subroutine process_close(fp,ierr)

   type(streampointer) :: fp
   integer             :: ierr
</pre><h2><a class="anchor" id="autotoc_md46"></a>
DESCRIPTION</h2>
<p>The M_process Fortran procedures use the ISO_C_BINDING interface to define Fortran-callable versions of the C procedures popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines are then used to create a simple Fortran-callable interface.</p>
<p>A POSIX C interface is generally available but may require using a Linux subwindow or an application such as CygWin on MSWindows platforms.</p>
<p>See "M_process" for an extended description.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
OPTIONS</h2>
<pre class="fragment">fp       C file pointer returned by process_open_*()
ierr     error flag returned.
</pre><h2><a class="anchor" id="autotoc_md48"></a>
EXAMPLES</h2>
<p>This example shows a simple open and close of a process</p>
<p>program demo_process_close use M_process ,ONLY: process_open_read, process_open_write use M_process ,ONLY: streampointer, process_close implicit none type(streampointer) :: fp integer :: ierr ! open process to read from call process_open_read('ls -l',fp,ierr) write(*,*)'CLOSE : process is opened with status ',ierr call process_close(fp,ierr) write(*,*)'CLOSE : process closed with status ',ierr end program demo_process_close</p>
<p>Sample output:</p>
<p>CLOSE : process is opened with status 0 CLOSE : process closed with status 13</p>
<h2><a class="anchor" id="autotoc_md49"></a>
SEE ALSO</h2>
<p>o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) o NAMED PIPES: mkfifo(3c), mknod(3c) o SUBPROCESSES: fork(3c) o OTHER: fflush(3c) </p>
<h2><a class="anchor" id="autotoc_md50"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md51"></a>
LICENSE</h2>
<p>Public Domain </p>

<p class="reference">References <a class="el" href="namespacem__process.html#a0fabee8d01338d5523fbdea5c5f1e894">process_debug</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__process_ab4c5cad3fb46686f0c9b71c3a634f6ae_icgraph.png" border="0" usemap="#namespacem__process_ab4c5cad3fb46686f0c9b71c3a634f6ae_icgraph" alt=""/></div>
<map name="namespacem__process_ab4c5cad3fb46686f0c9b71c3a634f6ae_icgraph" id="namespacem__process_ab4c5cad3fb46686f0c9b71c3a634f6ae_icgraph">
<area shape="rect" title=" " alt="" coords="204,5,355,47"/>
<area shape="rect" href="namespacem__process.html#a7dd759a1344789477ae1e205d7fa9a51" title=" " alt="" coords="5,5,156,47"/>
</map>
</div>

</div>
</div>
<a id="a3c0f543a9ceff2671041d73660f60a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0f543a9ceff2671041d73660f60a59">&#9670;&nbsp;</a></span>process_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, private m_process::process_open </td>
          <td>(</td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__process_1_1streampointer.html">streampointer</a>), intent(out)&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md38"></a>
NAME</h2>
<p>(LICENSE:PD) </p>
<h2><a class="anchor" id="autotoc_md39"></a>
SYNOPSIS</h2>
<h2><a class="anchor" id="autotoc_md40"></a>
DESCRIPTION</h2>
<h2><a class="anchor" id="autotoc_md41"></a>
EXAMPLE</h2>
<h2><a class="anchor" id="autotoc_md42"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md43"></a>
LICENSE</h2>
<p>Public Domain </p>

<p class="reference">References <a class="el" href="namespacem__process.html#a0fabee8d01338d5523fbdea5c5f1e894">process_debug</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__process_a3c0f543a9ceff2671041d73660f60a59_icgraph.png" border="0" usemap="#namespacem__process_a3c0f543a9ceff2671041d73660f60a59_icgraph" alt=""/></div>
<map name="namespacem__process_a3c0f543a9ceff2671041d73660f60a59_icgraph" id="namespacem__process_a3c0f543a9ceff2671041d73660f60a59_icgraph">
<area shape="rect" title=" " alt="" coords="403,46,592,73"/>
<area shape="rect" href="namespacem__process.html#aaaf4d1926258a4cec7da7fc61c38c79d" title=" " alt="" coords="204,5,355,47"/>
<area shape="rect" href="namespacem__process.html#aa6ed1404ab3472f5068ed15a7a01defc" title=" " alt="" coords="204,71,355,112"/>
<area shape="rect" href="namespacem__process.html#a7dd759a1344789477ae1e205d7fa9a51" title=" " alt="" coords="5,5,156,47"/>
</map>
</div>

</div>
</div>
<a id="aaaf4d1926258a4cec7da7fc61c38c79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf4d1926258a4cec7da7fc61c38c79d">&#9670;&nbsp;</a></span>process_open_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public m_process::process_open_read </td>
          <td>(</td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__process_1_1streampointer.html">streampointer</a>), intent(out)&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md22"></a>
NAME</h2>
<p>process_open_read(3fm) - [M_process] open a process for reading using POSIX interface (LICENSE:PD)</p>
<h2><a class="anchor" id="autotoc_md23"></a>
SYNOPSIS</h2>
<pre class="fragment"> subroutine process_open_read(cmd,fp,ierr)

   character(len=*)    :: cmd
   type(streampointer) :: fp
   integer             :: ierr
</pre><h2><a class="anchor" id="autotoc_md24"></a>
DESCRIPTION</h2>
<p>The M_process Fortran procedures use the ISO_C_BINDING interface to define Fortran-callable versions of the C procedures popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines are then used to create a simple Fortran-callable interface.</p>
<p>A POSIX C interface is generally available but may require using a Linux subwindow or an application such as CygWin on MSWindows platforms.</p>
<p>See "M_process" for an extended description.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
OPTIONS</h2>
<pre class="fragment">cmd      command passed to system to start process
fp       C file pointer returned by process_open_*()
ierr     error flag returned.

          o process_writeline(3f) : negative indicates an error
          o process_readline(3f)  : Non-zero indicates an error

maximum character value length is currently 4096
</pre><h2><a class="anchor" id="autotoc_md26"></a>
EXAMPLES</h2>
<p>This example shows a routine to read the output of a system command.</p>
<p>program demo_process_open_read use M_process ,ONLY: process_open_read, process_readline use M_process ,ONLY: streampointer, process_close implicit none type(streampointer) :: fp ! line of data to read (assumed long enough to hold any output line) character(len=4096) :: line integer :: ierr ! open process to read from call process_open_read('ls -l',fp,ierr) write(*,*)'READTEST: process is opened with status ',ierr ierr=0 do while(ierr .eq. 0) ! read a line from the process call process_readline(line,fp,ierr) if(ierr.ne.0)then write(*,*)'READTEST: ierr is ',ierr exit endif write(*,*)'READTEST: ',trim(line) enddo call process_close(fp,ierr) write(*,*)'READTEST: process closed with status ',ierr end program demo_process_open_read</p>
<p>Sample output:</p>
<p>READTEST: process is opened with status 0 READTEST: total 108 READTEST: -rw-r&ndash;r&ndash;. 1 urbanjs urbanjs 3731 Oct 17 14:49 build.sh READTEST: -rw-rw-r&ndash;. 1 urbanjs urbanjs 56633 Oct 17 14:50 build.sh.log READTEST: drwxrwxr-x. 3 urbanjs urbanjs 4096 Oct 17 14:50 doc READTEST: -rw-rw-r&ndash;. 1 urbanjs urbanjs 39459 Oct 17 15:16 M_process.ff READTEST: -rw-rw-r&ndash;. 1 urbanjs urbanjs 826 Oct 17 15:17 xx.f90 READTEST: ierr is -1 READTEST: process closed with status 0</p>
<h2><a class="anchor" id="autotoc_md27"></a>
SEE ALSO</h2>
<p>o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) o NAMED PIPES: mkfifo(3c), mknod(3c) o SUBPROCESSES: fork(3c) o OTHER: fflush(3c) </p>
<h2><a class="anchor" id="autotoc_md28"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md29"></a>
LICENSE</h2>
<p>Public Domain </p>

<p class="reference">References <a class="el" href="namespacem__process.html#a3c0f543a9ceff2671041d73660f60a59">process_open()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d_cgraph.png" border="0" usemap="#namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d_cgraph" alt=""/></div>
<map name="namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d_cgraph" id="namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,156,47"/>
<area shape="rect" href="namespacem__process.html#a3c0f543a9ceff2671041d73660f60a59" title=" " alt="" coords="204,13,393,39"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d_icgraph.png" border="0" usemap="#namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d_icgraph" alt=""/></div>
<map name="namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d_icgraph" id="namespacem__process_aaaf4d1926258a4cec7da7fc61c38c79d_icgraph">
<area shape="rect" title=" " alt="" coords="204,5,355,47"/>
<area shape="rect" href="namespacem__process.html#a7dd759a1344789477ae1e205d7fa9a51" title=" " alt="" coords="5,5,156,47"/>
</map>
</div>

</div>
</div>
<a id="aa6ed1404ab3472f5068ed15a7a01defc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ed1404ab3472f5068ed15a7a01defc">&#9670;&nbsp;</a></span>process_open_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public m_process::process_open_write </td>
          <td>(</td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__process_1_1streampointer.html">streampointer</a>), intent(out)&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md30"></a>
NAME</h2>
<p>process_open_write(3fm) - [M_process] open a process for writing using a POSIX interface (LICENSE:PD)</p>
<h2><a class="anchor" id="autotoc_md31"></a>
SYNOPSIS</h2>
<pre class="fragment"> subroutine process_open_write(cmd,fp,ierr)

   character(len=*)    :: cmd
   type(streampointer) :: fp
   integer             :: ierr
</pre><h2><a class="anchor" id="autotoc_md32"></a>
DESCRIPTION</h2>
<p>The M_process Fortran procedures use the ISO_C_BINDING interface to define Fortran-callable versions of the C procedures popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines are then used to create a simple Fortran-callable interface.</p>
<p>A POSIX C interface is generally available but may require using a Linux subwindow or an application such as CygWin on MSWindows platforms.</p>
<p>See "M_process" for an extended description.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
OPTIONS</h2>
<pre class="fragment">cmd      command passed to system to start process
fp       C file pointer returned by process_open_*()
ierr     error flag returned.

          o process_writeline(3f) : negative indicates an error
          o process_readline(3f)  : Non-zero indicates an error

maximum character value length is currently 4096
</pre><h2><a class="anchor" id="autotoc_md34"></a>
EXAMPLES</h2>
<p>This example shows a routine to write lines to the stdin of a system process</p>
<p>program demo_process_open_write use, intrinsic :: iso_fortran_env, only : &amp; &amp; stdin=&gt;input_unit, &amp; &amp; stdout=&gt;output_unit, &amp; &amp; stderr=&gt;error_unit use M_process ,ONLY: process_open_write, <a class="el" href="interfacem__process_1_1process__writeline.html">process_writeline</a> use M_process ,ONLY: streampointer, process_close implicit none type(streampointer) :: fp ! line of data to write character(len=4096) :: line integer :: ierr integer :: i ! open process to write to call process_open_write('cat -n',fp,ierr) write(stdout,*)'OPENWTEST: process is opened with status ',ierr ! remember C and Fortran I/O are often independent of each other flush(stdout) ierr=0 line='xxxxxxxxxxxxxxxxxxxxxxxxxxx' do i=1,10 ! write a line to the process call process_writeline(trim(line),fp,ierr) if(ierr.lt.0)then write(stdout,*)'OPENWTEST: ierr is ',ierr exit endif enddo call process_close(fp,ierr) write(stdout,*)'OPENWTEST: process closed with status ',ierr end program demo_process_open_write</p>
<p>Sample output:</p>
<p>&gt;OPENWTEST: process is opened with status 0 </p><blockquote class="doxtable">
<p>1 xxxxxxxxxxxxxxxxxxxxxxxxxxx 2 xxxxxxxxxxxxxxxxxxxxxxxxxxx 3 xxxxxxxxxxxxxxxxxxxxxxxxxxx 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx 5 xxxxxxxxxxxxxxxxxxxxxxxxxxx 6 xxxxxxxxxxxxxxxxxxxxxxxxxxx 7 xxxxxxxxxxxxxxxxxxxxxxxxxxx 8 xxxxxxxxxxxxxxxxxxxxxxxxxxx 9 xxxxxxxxxxxxxxxxxxxxxxxxxxx 10 xxxxxxxxxxxxxxxxxxxxxxxxxxx &gt;OPENWTEST: process closed with status 0 </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md35"></a>
SEE ALSO</h2>
<p>o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) o NAMED PIPES: mkfifo(3c), mknod(3c) o SUBPROCESSES: fork(3c) o OTHER: fflush(3c) </p>
<h2><a class="anchor" id="autotoc_md36"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md37"></a>
LICENSE</h2>
<p>Public Domain </p>

<p class="reference">References <a class="el" href="namespacem__process.html#a3c0f543a9ceff2671041d73660f60a59">process_open()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__process_aa6ed1404ab3472f5068ed15a7a01defc_cgraph.png" border="0" usemap="#namespacem__process_aa6ed1404ab3472f5068ed15a7a01defc_cgraph" alt=""/></div>
<map name="namespacem__process_aa6ed1404ab3472f5068ed15a7a01defc_cgraph" id="namespacem__process_aa6ed1404ab3472f5068ed15a7a01defc_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,156,47"/>
<area shape="rect" href="namespacem__process.html#a3c0f543a9ceff2671041d73660f60a59" title=" " alt="" coords="204,13,393,39"/>
</map>
</div>

</div>
</div>
<a id="a7dd759a1344789477ae1e205d7fa9a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd759a1344789477ae1e205d7fa9a51">&#9670;&nbsp;</a></span>process_readall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">character(len=:) function, allocatable, public m_process::process_readall </td>
          <td>(</td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in), optional&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out), optional&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md60"></a>
NAME</h2>
<p>process_readall(3f) - [M_process] read all lines from process into single string (LICENSE:PD) </p>
<h2><a class="anchor" id="autotoc_md61"></a>
SYNOPSIS</h2>
<p>syntax:</p>
<p>function process_readall(cmd,delim,ierr) result(string)</p>
<p>character(len=*),intent(in) :: cmd character(len=*),intent(in),optional :: delim integer,intent(out),optional :: ierr character(len=:),allocatable :: string </p>
<h2><a class="anchor" id="autotoc_md62"></a>
OPTIONS</h2>
<p>cmd command to pass to system delim delimiter to place between output lines when they are concatenated. Defaults to a space ierr check status of call. </p>
<h2><a class="anchor" id="autotoc_md63"></a>
RESULTS</h2>
<p>process_readall Assuming sufficient memory is available all the output of the system command are concatenated into a string with spaces added between the output lines of the command. </p>
<h2><a class="anchor" id="autotoc_md64"></a>
EXAMPLE</h2>
<p>Read all output of a command to a single string</p>
<p>program demo_process_readall use M_process, only: process_readall implicit none integer :: ierr character(len=:),allocatable :: string string=process_readall('ls',ierr=ierr) write(*,*)ierr,string end program demo_process_readall</p>
<p>Results:</p>
<p>app build docs example fpm.toml LICENSE man README.md src test</p>
<p>Read all output of a command to an array using split(3f)</p>
<p>program test_process_readall use M_process ,only: process_readall use M_strings ,only: split implicit none integer :: ierr integer :: i character(len=:),allocatable :: string character(len=:),allocatable :: array(:) string=process_readall('ls',delim=NEW_LINE("A"),ierr=ierr) call split(string,array,delimiters=NEW_LINE("A")) do i=1,size(array) write(*,'(i0,t10,"[",a,"]")')i,trim(array(i)) enddo write(*,*)string=process_readall(&amp; &amp; 'ls',delim=NEW_LINE("A"),ierr=ierr) write(*,*)string end program test_process_readall</p>
<p>Results: </p><pre class="fragment">&gt; 1     [Articles]
&gt; 2     [LIBRARY]
&gt; 3     [PC]
&gt; 4     [SHIP]
&gt; 5     [SPEC]
&gt; 6     [crib.dat]
&gt; 7     [doc]
&gt; 8     [html]
&gt; 9     [index.html]
&gt; 10    [plan.txt]
&gt; 11    [questions]
&gt; 12    [scripts]
&gt; 13    [tmp]
</pre><h2><a class="anchor" id="autotoc_md65"></a>
SEE ALSO</h2>
<p>M_process(3fm) </p>
<h2><a class="anchor" id="autotoc_md66"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md67"></a>
LICENSE</h2>
<p>Public Domain </p>

<p class="reference">References <a class="el" href="namespacem__process.html#ab4c5cad3fb46686f0c9b71c3a634f6ae">process_close()</a>, <a class="el" href="namespacem__process.html#aaaf4d1926258a4cec7da7fc61c38c79d">process_open_read()</a>, and <a class="el" href="namespacem__process.html#acbc72c5ed371430a471aa1f3010fbbda">process_readline()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__process_a7dd759a1344789477ae1e205d7fa9a51_cgraph.png" border="0" usemap="#namespacem__process_a7dd759a1344789477ae1e205d7fa9a51_cgraph" alt=""/></div>
<map name="namespacem__process_a7dd759a1344789477ae1e205d7fa9a51_cgraph" id="namespacem__process_a7dd759a1344789477ae1e205d7fa9a51_cgraph">
<area shape="rect" title=" " alt="" coords="5,71,156,112"/>
<area shape="rect" href="namespacem__process.html#ab4c5cad3fb46686f0c9b71c3a634f6ae" title=" " alt="" coords="204,5,355,47"/>
<area shape="rect" href="namespacem__process.html#aaaf4d1926258a4cec7da7fc61c38c79d" title=" " alt="" coords="204,71,355,112"/>
<area shape="rect" href="namespacem__process.html#acbc72c5ed371430a471aa1f3010fbbda" title=" " alt="" coords="204,136,355,177"/>
<area shape="rect" href="namespacem__process.html#a3c0f543a9ceff2671041d73660f60a59" title=" " alt="" coords="403,78,592,105"/>
</map>
</div>

</div>
</div>
<a id="acbc72c5ed371430a471aa1f3010fbbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc72c5ed371430a471aa1f3010fbbda">&#9670;&nbsp;</a></span>process_readline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public m_process::process_readline </td>
          <td>(</td>
          <td class="paramtype">character(len=*), intent(out)&#160;</td>
          <td class="paramname"><em>readfrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__process_1_1streampointer.html">streampointer</a>), intent(in)&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md52"></a>
NAME</h2>
<p>process_readline(3fm) - [M_process] read a line of output from a system command as a character variable (LICENSE:PD)</p>
<h2><a class="anchor" id="autotoc_md53"></a>
SYNOPSIS</h2>
<pre class="fragment"> subroutine process_readline(string,fp,ierr)

   character(len=*)    :: string
   type(streampointer) :: fp
   integer             :: ierr
</pre><h2><a class="anchor" id="autotoc_md54"></a>
DESCRIPTION</h2>
<p>The M_process Fortran procedures use the ISO_C_BINDING interface to define Fortran-callable versions of the C procedures popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines are then used to create a simple Fortran-callable interface.</p>
<p>A POSIX C interface is generally available but may require using a Linux subwindow or an application such as CygWin on MSWindows platforms.</p>
<p>See "M_process" for an extended description.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
OPTIONS</h2>
<pre class="fragment">string   data line to receive from process
fp       C file pointer returned by process_open_*()
ierr     error flag returned.

          o process_writeline(3f) : negative indicates an error
          o process_readline(3f)  : Non-zero indicates an error

maximum character value length is currently 4096
</pre><h2><a class="anchor" id="autotoc_md56"></a>
EXAMPLES</h2>
<p>This example shows a routine reading the output of a system command.</p>
<p>program demo_process_readline use M_process ,ONLY: process_open_read, process_readline use M_process ,ONLY: streampointer, process_close implicit none type(streampointer) :: fp ! line of data to read (assumed long enough to hold any output line) character(len=4096) :: line integer :: ierr ! open process to read from call process_open_read('ls -l',fp,ierr) write(*,*)'READLINE: process is opened with status ',ierr ierr=0 do while(ierr .eq. 0) ! read a line from the process call process_readline(line,fp,ierr) if(ierr.ne.0)then write(*,*)'READLINE: ierr is ',ierr exit endif write(*,*)'READLINE: ',trim(line) enddo call process_close(fp,ierr) write(*,*)'READLINE: process closed with status ',ierr end program demo_process_readline</p>
<p>Sample output:</p>
<p>READLINE: process is opened with status 0 READLINE: total 108 READLINE: -rw-r&ndash;r&ndash;. 1 urbanjs urbanjs 3731 Oct 17 14:49 build.sh READLINE: -rw-rw-r&ndash;. 1 urbanjs urbanjs 56633 Oct 17 14:50 build.sh.log READLINE: drwxrwxr-x. 3 urbanjs urbanjs 4096 Oct 17 14:50 doc READLINE: -rw-rw-r&ndash;. 1 urbanjs urbanjs 39459 Oct 17 15:16 M_process.ff READLINE: -rw-rw-r&ndash;. 1 urbanjs urbanjs 826 Oct 17 15:17 xx.f90 READLINE: ierr is -1 READLINE: process closed with status 0</p>
<h2><a class="anchor" id="autotoc_md57"></a>
SEE ALSO</h2>
<p>o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) o NAMED PIPES: mkfifo(3c), mknod(3c) o SUBPROCESSES: fork(3c) o OTHER: fflush(3c) </p>
<h2><a class="anchor" id="autotoc_md58"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md59"></a>
LICENSE</h2>
<p>Public Domain </p>

<p class="reference">References <a class="el" href="namespacem__process.html#a0fabee8d01338d5523fbdea5c5f1e894">process_debug</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__process_acbc72c5ed371430a471aa1f3010fbbda_icgraph.png" border="0" usemap="#namespacem__process_acbc72c5ed371430a471aa1f3010fbbda_icgraph" alt=""/></div>
<map name="namespacem__process_acbc72c5ed371430a471aa1f3010fbbda_icgraph" id="namespacem__process_acbc72c5ed371430a471aa1f3010fbbda_icgraph">
<area shape="rect" title=" " alt="" coords="204,5,355,47"/>
<area shape="rect" href="namespacem__process.html#a7dd759a1344789477ae1e205d7fa9a51" title=" " alt="" coords="5,5,156,47"/>
</map>
</div>

</div>
</div>
<a id="a08887a918eba167ceacddf58ca084270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08887a918eba167ceacddf58ca084270">&#9670;&nbsp;</a></span>process_writeline_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_process::process_writeline_array </td>
          <td>(</td>
          <td class="paramtype">character(len=*), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>writefrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__process_1_1streampointer.html">streampointer</a>), intent(in)&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespacem__process.html#a0fabee8d01338d5523fbdea5c5f1e894">process_debug</a>, and <a class="el" href="namespacem__process.html#a72527c0ec0af26dcb14b8bfad6dcd482">process_writeline_scalar()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__process_a08887a918eba167ceacddf58ca084270_cgraph.png" border="0" usemap="#namespacem__process_a08887a918eba167ceacddf58ca084270_cgraph" alt=""/></div>
<map name="namespacem__process_a08887a918eba167ceacddf58ca084270_cgraph" id="namespacem__process_a08887a918eba167ceacddf58ca084270_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,156,47"/>
<area shape="rect" href="namespacem__process.html#a72527c0ec0af26dcb14b8bfad6dcd482" title=" " alt="" coords="204,5,355,47"/>
</map>
</div>

</div>
</div>
<a id="a72527c0ec0af26dcb14b8bfad6dcd482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72527c0ec0af26dcb14b8bfad6dcd482">&#9670;&nbsp;</a></span>process_writeline_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_process::process_writeline_scalar </td>
          <td>(</td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>writefrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__process_1_1streampointer.html">streampointer</a>), intent(in)&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>ierr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>trm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md68"></a>
NAME</h2>
<p>process_writeline(3fm) - [M_process] write to a process using a POSIX interface (LICENSE:PD)</p>
<h2><a class="anchor" id="autotoc_md69"></a>
SYNOPSIS</h2>
<pre class="fragment"> subroutine process_writeline(string,fp,ierr)

   character(len=*)    :: string
   type(streampointer) :: fp
   integer             :: ierr
</pre><h2><a class="anchor" id="autotoc_md70"></a>
DESCRIPTION</h2>
<p>The M_process Fortran procedures use the ISO_C_BINDING interface to define Fortran-callable versions of the C procedures popen(3c)/pclose(3c) and fgets(3c)/fputs(3c). A set of record-oriented wrapper routines are then used to create a simple Fortran-callable interface.</p>
<p>A POSIX C interface is generally available but may require using a Linux subwindow or an application such as CygWin on MSWindows platforms.</p>
<p>See "M_process" for an extended description.</p>
<h2><a class="anchor" id="autotoc_md71"></a>
OPTIONS</h2>
<pre class="fragment">string   data line to to process
fp       C file pointer returned by process_open_*()
ierr     error flag returned.

          o process_writeline(3f) : negative indicates an error
          o process_readline(3f)  : Non-zero indicates an error

maximum character value length is currently 4096
</pre><h2><a class="anchor" id="autotoc_md72"></a>
EXAMPLES</h2>
<p>This example shows a routine to write lines to the stdin of a system process</p>
<p>program demo_process_writeline use, intrinsic :: iso_fortran_env, only : &amp; &amp; stdin=&gt;input_unit, &amp; &amp; stdout=&gt;output_unit, &amp; &amp; stderr=&gt;error_unit use <a class="el" href="namespacem__process.html">m_process</a> ,only: process_open_write, <a class="el" href="interfacem__process_1_1process__writeline.html">process_writeline</a> use <a class="el" href="namespacem__process.html">m_process</a> ,only: streampointer, process_close implicit none type(streampointer) :: fp ! line of data to write character(len=4096) :: line integer :: ierr integer :: i ! open process to write to call process_open_write('cat -n',fp,ierr) write(*,*)'WRITETEST: process is opened with status ',ierr ! remember C and Fortran I/O are often independent of each other flush(stdout) ierr=0 line='xxxxxxxxxxxxxxxxxxxxxxxxxxx' do i=1,10 ! write a line to the process call process_writeline(trim(line),fp,ierr) if(ierr.lt.0)then write(*,*)'WRITETEST: ierr is ',ierr exit endif enddo call process_close(fp,ierr) write(*,*)'WRITETEST: process closed with status ',ierr end program demo_process_writeline</p>
<p>Sample output:</p>
<p>&gt;WRITETEST: process is opened with status 0 </p><blockquote class="doxtable">
<p>1 xxxxxxxxxxxxxxxxxxxxxxxxxxx 2 xxxxxxxxxxxxxxxxxxxxxxxxxxx 3 xxxxxxxxxxxxxxxxxxxxxxxxxxx 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx 5 xxxxxxxxxxxxxxxxxxxxxxxxxxx 6 xxxxxxxxxxxxxxxxxxxxxxxxxxx 7 xxxxxxxxxxxxxxxxxxxxxxxxxxx 8 xxxxxxxxxxxxxxxxxxxxxxxxxxx 9 xxxxxxxxxxxxxxxxxxxxxxxxxxx 10 xxxxxxxxxxxxxxxxxxxxxxxxxxx &gt;WRITETEST: process closed with status 0 </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md73"></a>
SEE ALSO</h2>
<p>o PIPES: pipe(3c), popen(3c), pclose(3c), fflush(3c) o NAMED PIPES: mkfifo(3c), mknod(3c) o SUBPROCESSES: fork(3c) o OTHER: fflush(3c) </p>
<h2><a class="anchor" id="autotoc_md74"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md75"></a>
LICENSE</h2>
<p>Public Domain </p>

<p class="reference">References <a class="el" href="namespacem__process.html#a0fabee8d01338d5523fbdea5c5f1e894">process_debug</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__process_a72527c0ec0af26dcb14b8bfad6dcd482_icgraph.png" border="0" usemap="#namespacem__process_a72527c0ec0af26dcb14b8bfad6dcd482_icgraph" alt=""/></div>
<map name="namespacem__process_a72527c0ec0af26dcb14b8bfad6dcd482_icgraph" id="namespacem__process_a72527c0ec0af26dcb14b8bfad6dcd482_icgraph">
<area shape="rect" title=" " alt="" coords="204,5,355,47"/>
<area shape="rect" href="namespacem__process.html#a08887a918eba167ceacddf58ca084270" title=" " alt="" coords="5,5,156,47"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0fabee8d01338d5523fbdea5c5f1e894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fabee8d01338d5523fbdea5c5f1e894">&#9670;&nbsp;</a></span>process_debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical, public m_process::process_debug =.false.</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
